```{r}
# üîß Define root_dir at the top (set to project root)
root_dir <- "E:/Documents"
find_file <- function(filename) {
  paths <- c(
    "E:/Documents/data/processed",
    "E:/Documents/LUAD_Biomarker_Project/data/processed",
    "E:/Documents"
  )
  for (p in paths) {
    full_path <- file.path(p, filename)
    if (file.exists(full_path)) return(full_path)
  }
  stop(paste("‚ùå File", filename, "not found"))
}

# Usage
go_enrich_path <- find_file("GO_Enrichment_Results.csv")
df <- read.csv(go_enrich_path)


```

```{r dynamic-paths}

# üîç Attempt to find "TCGA_LUAD_biospecimen.csv"
biospecimen_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "TCGA_LUAD_biospecimen.csv")
if (length(biospecimen_file) == 0) {
  stop("‚ùå ERROR: 'TCGA_LUAD_biospecimen.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(biospecimen_file)} at {dirname(biospecimen_file)}\n"))
}


# üîç Attempt to find "TCGA_LUAD_clinical.csv"
clinical_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "TCGA_LUAD_clinical.csv")
if (length(clinical_file) == 0) {
  stop("‚ùå ERROR: 'TCGA_LUAD_clinical.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(clinical_file)} at {dirname(clinical_file)}\n"))
}


# üîç Attempt to find "TCGA_LUAD_methylation_beta_matrix.rds"
meth_beta_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "TCGA_LUAD_methylation_beta_matrix.rds")
if (length(meth_beta_file) == 0) {
  stop("‚ùå ERROR: 'TCGA_LUAD_methylation_beta_matrix.rds' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(meth_beta_file)} at {dirname(meth_beta_file)}\n"))
}


# üîç Attempt to find "TCGA_LUAD_methylation_gene_matrix.rds"
meth_gene_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "TCGA_LUAD_methylation_gene_matrix.rds")
if (length(meth_gene_file) == 0) {
  stop("‚ùå ERROR: 'TCGA_LUAD_methylation_gene_matrix.rds' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(meth_gene_file)} at {dirname(meth_gene_file)}\n"))
}


# üîç Attempt to find "sample_mapping.csv"
mapping_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "sample_mapping.csv")
if (length(mapping_file) == 0) {
  stop("‚ùå ERROR: 'sample_mapping.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(mapping_file)} at {dirname(mapping_file)}\n"))
}


# üîç Attempt to find "combined_omics_data.csv"
combined_omics_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "combined_omics_data.csv")
if (length(combined_omics_file) == 0) {
  stop("‚ùå ERROR: 'combined_omics_data.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(combined_omics_file)} at {dirname(combined_omics_file)}\n"))
}


# üîç Attempt to find "DEGs_Tumor_vs_Normal.csv"
deg_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "DEGs_Tumor_vs_Normal.csv")
if (length(deg_file) == 0) {
  stop("‚ùå ERROR: 'DEGs_Tumor_vs_Normal.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(deg_file)} at {dirname(deg_file)}\n"))
}


# üîç Attempt to find "GO_Enrichment_Results.csv"
go_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "GO_Enrichment_Results.csv")
if (length(go_file) == 0) {
  stop("‚ùå ERROR: 'GO_Enrichment_Results.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(go_file)} at {dirname(go_file)}\n"))
}


# üîç Attempt to find "GSE43458_symbol_expression.csv"
geo_gse43458_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "GSE43458_symbol_expression.csv")
if (length(geo_gse43458_file) == 0) {
  stop("‚ùå ERROR: 'GSE43458_symbol_expression.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(geo_gse43458_file)} at {dirname(geo_gse43458_file)}\n"))
}


# üîç Attempt to find "GSE135222_expression_cleaned.csv"
geo_gse135222_file <- list.files(root_dir, recursive = TRUE, full.names = TRUE, pattern = "GSE135222_expression_cleaned.csv")
if (length(geo_gse135222_file) == 0) {
  stop("‚ùå ERROR: 'GSE135222_expression_cleaned.csv' not found in any subdirectory of the root project.")
} else {
  cat(glue::glue("‚úÖ Found file: {basename(geo_gse135222_file)} at {dirname(geo_gse135222_file)}\n"))
}

```

```{r load-packages}
library(tidyverse)
library(janitor)
library(limma)
library(pheatmap)
library(survival)
library(survminer)
library(ggrepel)
library(org.Hs.eg.db)
library(clusterProfiler)
```

## Load Data

```{r load-data}
expr_df <- read_csv("data/processed/TCGA_LUAD_expression_matched.csv") %>% clean_names()
meta_df <- read_csv("data/processed/TCGA_LUAD_sample_metadata.csv") %>% clean_names()

rownames(expr_df) <- expr_df$sample
expr_mat <- expr_df[, -1] %>% as.matrix()
```

## Expression Matrix QC

```{r expr-qc}
expr_matrix_qc <- expr_mat[apply(expr_mat, 1, sd) > 0, ]
expr_matrix_qc <- expr_matrix_qc[rowSums(expr_matrix_qc > 1) >= 5, ]
meta_df <- meta_df %>% filter(expr_id %in% colnames(expr_matrix_qc)) %>% arrange(match(expr_id, colnames(expr_matrix_qc)))
```

## DEG Analysis

```{r deg-analysis}
group <- factor(meta_df$sample_group, levels = c("Normal", "Tumor"))
design <- model.matrix(~ group)
fit <- lmFit(expr_matrix_qc, design)
fit <- eBayes(fit)
deg_results <- topTable(fit, coef = 2, number = Inf, adjust.method = "fdr") %>%
  rownames_to_column("gene_symbol") %>%
  as_tibble()
deg_filtered <- deg_results %>% filter(adj.P.Val < 0.05 & abs(logFC) > 1)
write_csv(deg_results, "results/TCGA_LUAD_DEG_all.csv")
write_csv(deg_filtered, "results/TCGA_LUAD_DEG_significant.csv")
cat("‚úÖ Total significant DEGs:", nrow(deg_filtered), "\n")
knitr::kable(
  head(deg_filtered, 20),
  caption = "Top 20 Significant Differentially Expressed Genes (FDR < 0.05 & |logFC| > 1)"
)


```

## Volcano Plot

```{r volcano-plot, fig.width=7, fig.height=6}
# Filter to valid numeric values only
volcano_df <- deg_results %>%
  filter(is.finite(logFC), is.finite(adj.P.Val)) %>%
  mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

# Plot
ggplot(volcano_df, aes(x = logFC, y = -log10(adj.P.Val), color = Significant)) +
  geom_point(alpha = 0.6) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot: Tumor vs Normal", x = "log2 Fold Change", y = "-log10 Adjusted P-Value") +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed")
cat("Total DEGs plotted:", nrow(volcano_df), "\n")

```

```{r}
# Make sure deg_filtered is already created
# deg_filtered <- deg_results %>% filter(adj.P.Val < 0.05 & abs(logFC) > 1)

# Total significant DEGs
total_degs <- nrow(deg_filtered)

# Upregulated in Tumor (logFC > 1)
up_degs <- deg_filtered %>% filter(logFC > 1) %>% nrow()

# Downregulated in Tumor (logFC < -1)
down_degs <- deg_filtered %>% filter(logFC < -1) %>% nrow()

# Print summary
cat("‚úÖ Differential Expression Summary:\n")
cat("Total DEGs (adj.P.Val < 0.05 & |logFC| > 1):", total_degs, "\n")
cat("Upregulated in Tumor:", up_degs, "\n")
cat("Downregulated in Tumor:", down_degs, "\n")
# Top 5 Upregulated
head(deg_filtered %>% filter(logFC > 1) %>% arrange(desc(logFC)), 5)

# Top 5 Downregulated
head(deg_filtered %>% filter(logFC < -1) %>% arrange(logFC), 5)

```



#### MA Plot

```{r}
library(ggplot2)
library(ggrepel)
library(dplyr)

# Remove rows with NA in critical columns
ma_df <- deg_results %>%
  filter(is.finite(AveExpr), is.finite(logFC), !is.na(gene_symbol))

# Mark significant genes
ma_df <- ma_df %>%
  mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

# Label top 5 up- and down-regulated significant genes
top_up <- ma_df %>% filter(Significant, logFC > 1) %>% arrange(-logFC) %>% head(5)
top_down <- ma_df %>% filter(Significant, logFC < -1) %>% arrange(logFC) %>% head(5)
label_genes <- bind_rows(top_up, top_down)

# MA plot
ma_plot <- ggplot(ma_df, aes(x = AveExpr, y = logFC, color = Significant)) +
  geom_point(alpha = 0.5, size = 1) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal(base_size = 14) +
  labs(
    title = "MA Plot: Tumor vs Normal",
    x = "Average Expression (AveExpr)",
    y = "log2 Fold Change (logFC)"
  ) +
  geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "blue") +
  guides(color = guide_legend(title = "Significant")) +
  geom_text_repel(
    data = label_genes,
    aes(label = gene_symbol),
    size = 3,
    max.overlaps = Inf
  )

# Show in a new window if interactive
if (interactive()) {
  print(ma_plot)
} else {
  ma_plot
}
```

```{r}
# Libraries
library(ggplot2)
library(ggrepel)

# Assume deg_results is already loaded, e.g.:
# deg_results <- read.csv("results/TCGA_LUAD_DEG_all.csv")

# Prepare data for MA plot
ma_df <- deg_results %>%
  dplyr::mutate(
    Significant = adj.P.Val < 0.05 & abs(logFC) > 1
  )

# Get top 5 up and down regulated genes for labeling
top_up <- ma_df %>%
  dplyr::filter(Significant, logFC > 1) %>%
  dplyr::arrange(-logFC) %>%
  head(5)

top_down <- ma_df %>%
  dplyr::filter(Significant, logFC < -1) %>%
  dplyr::arrange(logFC) %>%
  head(5)

label_genes <- dplyr::bind_rows(top_up, top_down)

# Plot MA
ma_plot <- ggplot(ma_df, aes(x = AveExpr, y = logFC, color = Significant)) +
  geom_point(alpha = 0.5, size = 1) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal(base_size = 14) +
  labs(
    title = "MA Plot: Tumor vs Normal",
    x = "Average Expression (AveExpr)",
    y = "log2 Fold Change (logFC)"
  ) +
  geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "blue") +
  guides(color = guide_legend(title = "Significant"))

# Add gene labels
if (nrow(label_genes) > 0) {
  ma_plot <- ma_plot +
    ggrepel::geom_text_repel(
      data = label_genes,
      aes(label = gene_symbol),
      size = 3,
      max.overlaps = Inf
    )
}

# Show in new window (if not in RMarkdown/knit)
if (interactive()) {
  print(ma_plot)
} else {
  ma_plot
}
```

## Heatmap

```{r heatmap}
expr_df <- read.csv("TCGA_LUAD_expression_percentile.csv", check.names = FALSE)

# ‚úÖ Set rownames from first column
rownames(expr_df) <- expr_df[[1]]
expr_df <- expr_df[, -1]

# ‚úÖ Convert to matrix
expr_matrix_qc <- as.matrix(expr_df)

# üîç Now check
head(rownames(expr_matrix_qc), 10)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(matrixStats)
library(pheatmap)
library(dplyr)
library(tibble)

# ‚úÖ 1. Clean DEG data
deg_filtered <- as_tibble(as.data.frame(deg_filtered))

# ‚úÖ 2. Convert Entrez IDs to SYMBOLs
gene_symbols <- mapIds(
  org.Hs.eg.db,
  keys = deg_filtered$gene_symbol,
  keytype = "ENTREZID",
  column = "SYMBOL",
  multiVals = "first"
)

deg_filtered$gene_symbol_mapped <- gene_symbols

# ‚úÖ 3. Top 30 mapped SYMBOLs
top_symbols <- deg_filtered %>%
  filter(!is.na(gene_symbol_mapped)) %>%
  arrange(adj.P.Val) %>%
  slice_head(n = 30) %>%
  pull(gene_symbol_mapped)

# ‚úÖ 4. Match to expression matrix rownames
expr_genes <- rownames(expr_matrix_qc)
matched_rows <- expr_genes[toupper(expr_genes) %in% toupper(top_symbols)]

cat("üß¨ Matched SYMBOL genes for heatmap:", length(matched_rows), "\n")
print(matched_rows)

if (length(matched_rows) < 2) stop("‚ùå Less than 2 matched genes ‚Äî cannot cluster.")

# ‚úÖ 5. Subset + scale
heatmap_matrix <- expr_matrix_qc[matched_rows, , drop = FALSE]
heatmap_matrix <- heatmap_matrix[rowSds(heatmap_matrix, na.rm = TRUE) > 0, ]
heatmap_matrix_z <- t(scale(t(heatmap_matrix)))
heatmap_matrix_z <- heatmap_matrix_z[complete.cases(heatmap_matrix_z), ]

if (nrow(heatmap_matrix_z) < 2) stop("‚ùå Final heatmap has <2 genes after scaling.")

# ‚úÖ 6. Plot
pheatmap(
  heatmap_matrix_z,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  show_rownames = TRUE,
  show_colnames = FALSE,
  main = "üî• Top 30 DEGs in LUAD (Entrez ‚Üí SYMBOL)"
)
annotation_col = data.frame(Group = group)


```

```{r}
# Load the main TCGA LUAD clinical data
clinical_data <- readRDS("E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_Clinical.rds")

# Inspect the structure
str(clinical_data)

# Preview top rows
head(clinical_data)

# View column names
colnames(clinical_data)

```

```{r}
# ‚úÖ Load clinical data (already done)
clinical_data <- readRDS("TCGA_LUAD_Clinical.rds")

# ‚úÖ Convert patient ID (12-character TCGA barcode)
clinical_data$sample_id <- substr(clinical_data$submitter_id, 1, 12)

# ‚úÖ Standardize and compute survival time and event
clinical_data_clean <- clinical_data %>%
  mutate(
    vital_status = tolower(vital_status),
    event = case_when(
      vital_status == "dead" ~ 1,
      vital_status == "alive" ~ 0,
      TRUE ~ NA_real_
    ),
    surv_time = case_when(
      !is.na(days_to_death) ~ days_to_death,
      !is.na(days_to_last_follow_up) ~ days_to_last_follow_up,
      TRUE ~ NA_real_
    ),
    age_at_initial_pathologic_diagnosis = age_at_diagnosis  # rename for consistency
  ) %>%
  filter(!is.na(event), !is.na(surv_time)) %>%
  select(sample_id, event, surv_time, gender, age_at_initial_pathologic_diagnosis)

# ‚úÖ Summary
cat("‚úÖ Cleaned clinical samples with survival data:", nrow(clinical_data_clean), "\n")
print(head(clinical_data_clean, 3))

```

```{r}
expr_df <- read.csv("E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_expression_percentile.csv", check.names = FALSE)

# Inspect
cat("First few column names of expression matrix:\n")
print(colnames(expr_df)[1:10])
print(head(expr_df[, 1:5]))

# Rebuild expression matrix
rownames(expr_df) <- expr_df[[1]]
expr_df <- expr_df[, -1]
colnames(expr_df) <- substr(colnames(expr_df), 1, 12)  # optional barcode truncation

expr_matrix_qc <- apply(expr_df, 2, as.numeric)
rownames(expr_matrix_qc) <- rownames(expr_df)
expr_matrix_qc <- as.matrix(expr_matrix_qc)

```

```{r}
metadata <- read.csv("E:/Documents/LUAD_Biomarker_Project/data/processed/TCGA_LUAD_clinical.csv", check.names = FALSE, stringsAsFactors = FALSE)

# Inspect
cat("Column names in metadata:\n")
print(colnames(metadata))
print(head(metadata[, 1:5]))  # show first few columns

# Try to identify the sample ID column
if ("sample_id" %in% colnames(metadata)) {
  print("‚úÖ Found sample_id column")
} else {
  print("‚ùå 'sample_id' column not found ‚Äî check if it's called 'bcr_patient_barcode' or similar")
}

```
```{r}
expr_path <- "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_expression_percentile.csv"

# Reload from scratch
expr_df <- read.csv(expr_path, check.names = FALSE, stringsAsFactors = FALSE)

# Check first few rows and colnames
head(expr_df, 3)
colnames(expr_df)[1:10]

```
```{r}
colnames(expr_df)[1] <- "GeneSymbol"
# Convert sample IDs to uppercase TCGA style
colnames(expr_df) <- toupper(gsub("_", "-", colnames(expr_df)))

# Set row names to gene names
rownames(expr_df) <- expr_df$GeneSymbol

# Remove gene symbol column from matrix
expr_df <- expr_df[, -1]
# Convert all columns to numeric and reattach rownames
expr_matrix_qc <- as.matrix(sapply(expr_df, as.numeric))
rownames(expr_matrix_qc) <- rownames(expr_df)

# Final check
dim(expr_matrix_qc)

```


```{r}
# Truncate metadata sample IDs to 15-character TCGA barcode format
metadata$sample_id <- toupper(metadata$sampleID)
metadata$sample_id <- substr(metadata$sample_id, 1, 15)

# Match sample IDs
common_samples <- intersect(colnames(expr_matrix_qc), metadata$sample_id)
expr_matrix_qc <- expr_matrix_qc[, common_samples]
metadata <- metadata[match(common_samples, metadata$sample_id), ]

cat("‚úÖ Matched samples:", length(common_samples), "\n")

```
```{r}
metadata$group <- ifelse(grepl("-01$", metadata$sample_id), "Tumor",
                         ifelse(grepl("-11$", metadata$sample_id), "Normal", NA))

# Clean and factor
metadata <- metadata[!is.na(metadata$group), ]
metadata$group <- factor(metadata$group, levels = c("Normal", "Tumor"))

# Final check
table(metadata$group)

```

```{r}
cat("Expression matrix columns (samples):", ncol(expr_matrix_qc), "\n")
cat("Design matrix rows (samples):", nrow(design), "\n")

```
```{r}
expr_samples <- colnames(expr_matrix_qc)
meta_samples <- metadata$sample_id

# Samples in expression but not in metadata
extra_expr <- setdiff(expr_samples, meta_samples)
cat("‚ö†Ô∏è Extra samples in expression matrix:", extra_expr, "\n")

# Samples in metadata but not in expression (optional)
extra_meta <- setdiff(meta_samples, expr_samples)
cat("‚ÑπÔ∏è Samples in metadata but not expression:", extra_meta, "\n")

```


```{r}
# Define common samples
common_samples <- intersect(colnames(expr_matrix_qc), metadata$sample_id)

# Subset expression and metadata
expr_matrix_qc <- expr_matrix_qc[, common_samples]
metadata <- metadata[match(common_samples, metadata$sample_id), ]

# Sanity check
stopifnot(identical(colnames(expr_matrix_qc), metadata$sample_id))
cat("‚úÖ Final matched sample count:", length(common_samples), "\n")


```
```{r}
deg_all <- topTable(fit2, adjust.method = "BH", number = Inf)
cat("Total DEGs before filtering:", nrow(deg_all), "\n")

summary(deg_all$logFC)
summary(deg_all$adj.P.Val)

```
```{r}
# üì• Load expression matrix
expr_path <- "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_TPM_log2.csv"
expr_df <- read.csv(expr_path, check.names = FALSE)

# üßπ Clean: Set gene names as rownames
rownames(expr_df) <- expr_df$sample
expr_df <- expr_df[, -1]

# üîç Confirm dimensions
cat("Expression matrix dimensions:\n")
print(dim(expr_df))  # Genes x Samples

# üí° Fix column names: Match sample barcodes with metadata
colnames(expr_df) <- gsub("\\.", "-", colnames(expr_df))  # UCSC Xena uses TCGA-XX-XXXX

# üß™ Optional sanity check
print(expr_df[1:3, 1:3])

```


```{r}
# üì¶ Required package
if (!require("curl")) install.packages("curl")

# ‚úÖ Download from Xena functional data hub
download.file(
  url = "https://tcga.xenahubs.net/download/TCGA.LUAD.sampleMap/HiSeqV2.gz",
  destfile = "E:/Documents/LUAD_Biomarker_Project/TCGA.LUAD.sampleMap.HiSeqV2.gz",
  mode = "wb"
)

cat("‚úÖ Download complete.\n")

```

```{r}
library(readr)

# üîç Path to downloaded file
gz_file <- "E:/Documents/LUAD_Biomarker_Project/TCGA.LUAD.sampleMap.HiSeqV2.gz"

# üì• Read the Xena-formatted matrix (skip metadata row)
expr_df <- read_tsv(gz_file, skip = 1)

# üß¨ Extract gene symbols and set as rownames
gene_symbols <- expr_df[[1]]
expr_df <- expr_df[, -1]
rownames(expr_df) <- gene_symbols

# üí° Convert to numeric matrix
expr_matrix <- as.matrix(expr_df)
storage.mode(expr_matrix) <- "numeric"

# üßΩ Optional cleanup: replace "." with "-" in sample names
colnames(expr_matrix) <- gsub("\\.", "-", colnames(expr_matrix))

# üíæ Save cleaned matrix
write.csv(expr_matrix, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_TPM_log2_cleaned.csv")
saveRDS(expr_matrix, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_TPM_log2_cleaned.rds")

cat("‚úÖ Expression matrix ready. Dimensions: ", dim(expr_matrix), "\n")

```

```{r}
library(readr)

# File path
gz_file <- "E:/Documents/LUAD_Biomarker_Project/TCGA.LUAD.sampleMap.HiSeqV2.gz"

# Step 1: Read the header only (first row)
header <- read_lines(gz_file, n_max = 1)
sample_ids <- unlist(strsplit(header, "\t"))[-1]  # drop the first column name

# Step 2: Read the actual expression matrix (skip header row)
expr_df <- read_tsv(gz_file, skip = 1, col_names = FALSE)

# Step 3: Assign proper names
gene_symbols <- expr_df[[1]]
expr_data <- expr_df[, -1]
colnames(expr_data) <- sample_ids
rownames(expr_data) <- gene_symbols

# Step 4: Convert to numeric matrix
expr_matrix <- as.matrix(expr_data)
storage.mode(expr_matrix) <- "numeric"

# ‚úÖ Clean and save
write.csv(expr_matrix, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_TPM_log2_cleaned.csv")
saveRDS(expr_matrix, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_TPM_log2_cleaned.rds")

cat("‚úÖ Final cleaned expression matrix ready!\nDimensions: ", dim(expr_matrix), "\n")

```

```{r}
# üîÅ Step 1: Force reinstall UCSCXenaTools from CRAN
remove.packages("UCSCXenaTools")
install.packages("UCSCXenaTools")

# üîÅ Step 2: Restart R session (Ctrl + Shift + F10 in RStudio)

# ‚úÖ Step 3: Load it and check functions
library(UCSCXenaTools)

# ‚úÖ Step 4: Check available functions
ls("package:UCSCXenaTools")

```
```{r}
# üì¶ Load UCSCXenaTools
library(UCSCXenaTools)

# üß¨ Step 1: Define LUAD clinical matrix dataset
query <- XenaGenerate(
  datasets = "TCGA.LUAD.sampleMap/clinicalMatrix",
  hosts = "https://tcga.xenahubs.net"
)

# üì• Step 2: Download to your project directory
query <- XenaDownload(query, destdir = "E:/Documents/LUAD_Biomarker_Project")

# üìÇ Step 3: Prepare the clinical matrix (as data frame)
clinical_df <- XenaPrepare(query)

# üíæ Step 4: Save for reuse
saveRDS(clinical_df, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_clinical.rds")
write.csv(clinical_df, "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_clinical.csv", row.names = TRUE)

# üß™ Step 5: Preview
head(clinical_df[, 1:5])

```


```{r}
genes_of_interest <- c("HIF3A", "EGFR", "KRAS")

# Check availability
genes_found <- rownames(expr_matrix_qc)[toupper(rownames(expr_matrix_qc)) %in% toupper(genes_of_interest)]
genes_found

```

```{r}
# ‚úÖ Define expression path safely
expr_path <- "E:/Documents/LUAD_Biomarker_Project/TCGA_LUAD_expression_percentile.csv"

if (!file.exists(expr_path)) {
  stop("‚ùå Expression file not found at: ", expr_path)
}

# ‚úÖ Load and preprocess expression data
expr_df <- read.csv(expr_path, check.names = FALSE)

# Set row names and drop the first column
rownames(expr_df) <- expr_df[[1]]
expr_df <- expr_df[, -1]

# Ensure matrix conversion is safe and track NAs
expr_matrix_qc <- suppressWarnings(apply(expr_df, 2, as.numeric))
expr_matrix_qc <- as.matrix(expr_matrix_qc)
rownames(expr_matrix_qc) <- rownames(expr_df)

# Check for EGFR presence before summary
if ("EGFR" %in% rownames(expr_matrix_qc)) {
  cat("‚úÖ EGFR summary:\n")
  print(summary(expr_matrix_qc["EGFR", ]))
  cat("EGFR SD:\n")
  print(sd(expr_matrix_qc["EGFR", ], na.rm = TRUE))
} else {
  warning("‚ö†Ô∏è EGFR not found in expression matrix.")
}

# Ensure DEGs object exists
if (exists("deg_filtered")) {
  genes_of_interest <- head(deg_filtered$gene_symbol, 50)
} else {
  warning("‚ö†Ô∏è DEG object 'deg_filtered' not found. Skipping gene selection.")
}

```

```{r}
head(rownames(expr_matrix_qc), 10)
known_genes <- c("EGFR", "TP53", "KRAS", "CDKN2A", "MYC", "AKT1", "GAPDH")
intersect(known_genes, rownames(expr_matrix_qc))

```

```{r}
# üîß Clean colnames in expr_matrix_qc
colnames(expr_matrix_qc) <- toupper(colnames(expr_matrix_qc))
colnames(expr_matrix_qc) <- gsub("_", "-", colnames(expr_matrix_qc))
colnames(expr_matrix_qc) <- sub("-01$", "", colnames(expr_matrix_qc))  # Remove sample suffixes
colnames(expr_matrix_qc) <- sub("-11$", "", colnames(expr_matrix_qc))

# üîß Clean clinical sample IDs
clinical_data_clean$sample_id <- toupper(clinical_data_clean$sample_id)
clinical_data_clean$sample_id <- gsub("_", "-", clinical_data_clean$sample_id)
clinical_data_clean$sample_id <- sub("-01$", "", clinical_data_clean$sample_id)
clinical_data_clean$sample_id <- sub("-11$", "", clinical_data_clean$sample_id)

# ‚úÖ Now align samples
matched_samples <- intersect(colnames(expr_matrix_qc), clinical_data_clean$sample_id)
cat("‚úÖ Matched samples:", length(matched_samples), "\n")

# Subset
expr_matrix_qc <- expr_matrix_qc[, matched_samples]
clinical_data_clean <- clinical_data_clean %>%
  filter(sample_id %in% matched_samples) %>%
  arrange(match(sample_id, colnames(expr_matrix_qc)))

```

```{r}
run_survival_analysis <- function(expr_matrix, clinical_df, gene_list,
                                  output_dir = "results", plot_dir = "figures") {
  dir.create(output_dir, showWarnings = FALSE)
  dir.create(plot_dir, showWarnings = FALSE)

  results_list <- list()

  for (gene in gene_list) {
    message("üîç Processing gene: ", gene)

    if (!gene %in% rownames(expr_matrix)) {
      message("‚ùå Skipping ", gene, ": not in expression matrix.")
      next
    }

    expr_vec <- expr_matrix[gene, ]

    if (all(is.na(expr_vec)) || length(na.omit(expr_vec)) < 10 || sd(expr_vec, na.rm = TRUE) == 0) {
      message("‚ö†Ô∏è Skipping ", gene, ": not enough valid expression values.")
      next
    }

    matched_samples <- intersect(colnames(expr_matrix), clinical_df$sample_id)
    expr_vec <- expr_vec[matched_samples]

    clin_gene <- clinical_df %>%
      filter(sample_id %in% matched_samples) %>%
      mutate(expr = expr_vec[match(sample_id, matched_samples)]) %>%
      filter(!is.na(expr))

    if (nrow(clin_gene) < 20) {
      message("‚ö†Ô∏è Skipping ", gene, ": fewer than 20 valid samples.")
      next
    }

    cut <- tryCatch({
      surv_cutpoint(clin_gene, time = "surv_time", event = "event", variables = "expr")
    }, error = function(e) {
      message("‚ùå Error in cutpoint for ", gene, ": ", e$message)
      return(NULL)
    })

    if (is.null(cut)) next

    group <- surv_categorize(cut)
    clin_gene$gene_group <- group$expr
    clin_gene$gender <- as.factor(clin_gene$gender)

    cox_uni <- coxph(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    cox_multi <- tryCatch({
      coxph(Surv(surv_time, event) ~ gene_group + age_at_initial_pathologic_diagnosis + gender, data = clin_gene)
    }, error = function(e) {
      message("‚ùå Multivariate Cox error for ", gene, ": ", e$message)
      return(NULL)
    })

    if (is.null(cox_multi)) next

    results_list[[gene]] <- list(
      cutpoint = cut$cutpoint$expr,
      cox_uni = summary(cox_uni),
      cox_multi = summary(cox_multi)
    )

    # KM plot
    fit <- survfit(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    plot_file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
    plot_obj <- ggsurvplot(
      fit,
      data = clin_gene,
      pval = TRUE,
      risk.table = TRUE,
      legend.title = gene,
      legend.labs = c("Low", "High"),
      title = paste("Survival by", gene, "Expression"),
      palette = c("steelblue", "firebrick")
    )
    ggsave(filename = plot_file, plot = plot_obj$plot, width = 7, height = 5, dpi = 300)
  }

  # SAFETY CHECK
  if (length(results_list) == 0) {
    message("üö´ No valid genes passed survival filtering. Skipping forest plot.")
    return(NULL)
  }

  forest_data <- do.call(rbind, lapply(names(results_list), function(gene) {
    row <- results_list[[gene]]$cox_multi$coefficients["gene_groupHigh", ]
    data.frame(
      gene = gene,
      HR = exp(row["coef"]),
      lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
      upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
      pvalue = row["Pr(>|z|)"]
    )
  }))

  write.csv(forest_data, file.path(output_dir, "cox_multivariate_summary.csv"), row.names = FALSE)

  forest_data <- forest_data[order(forest_data$HR, decreasing = TRUE), ]
  forest_data$gene <- factor(forest_data$gene, levels = forest_data$gene)

  forest_plot <- ggplot(forest_data, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
    geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
    coord_flip() +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue"),
                       labels = c("Significant", "Not Significant")) +
    labs(
      title = "Forest Plot: Multivariate Cox Models",
      subtitle = "Adjusted for age and gender",
      x = "Gene", y = "Hazard Ratio (HR)", color = "Significance"
    ) +
    geom_text(aes(label = sprintf("p=%.3f", pvalue)), hjust = -0.1, color = "black", size = 4) +
    theme_minimal(base_size = 14)

  ggsave(file.path(plot_dir, "cox_forest_plot.png"), forest_plot, width = 10, height = 6, dpi = 300)
  message("‚úÖ Forest plot saved.")

  return(results_list)
}


```

```{r}
ls()  # See what variables are loaded
expr_df <- read_csv("data/processed/TCGA_LUAD_expression_matched.csv") %>% clean_names()
rownames(expr_df) <- expr_df$sample
expr_matrix <- as.matrix(expr_df[, -1])
```

```{r}
library(readr)
expr_df <- as.data.frame(read_csv("data/processed/TCGA_LUAD_expression_matched.csv"))  # Replace with your actual path
rownames(expr_df) <- expr_df$sample
expr_df <- expr_df[, -1]  # remove the 'sample' column
expr_matrix <- as.matrix(expr_df)
head(rownames(expr_matrix), 10)  # Check you have gene symbols as rownames now!
```

```{r}
library(readr)
clinical_df <- read_csv("data/processed/TCGA_LUAD_expression_matched.csv")  
head(clinical_df)
```

```{r}
library(tidyverse)

# 1. Pivot clinical_df from wide to long, then to tidy format
clinical_long <- clinical_df %>%
  pivot_longer(-sample, names_to = "sample_id", values_to = "value") %>%
  pivot_wider(names_from = sample, values_from = value)

# 2. Check the result!
head(clinical_long)

# Now you have a data.frame where:
# - clinical_long$sample_id matches colnames(expr_matrix)
# - Clinical variables are columns (e.g., vital_status, days_to_death, etc.)
```

```{r}
# Load the data (tab-separated)
expr_df <- read.table("expression_transposed.tsv", header = TRUE, row.names = 1, sep = "\t", check.names = FALSE)

# Inspect the dimensions
dim(expr_df)
# Should be: [number of samples, number of genes] (e.g., 576 x 20530)

# If you need the usual format [genes x samples], transpose it:
expr_matrix <- t(as.matrix(expr_df))

# Now:
# - rows are genes (gene symbols)
# - columns are samples (sample IDs)
dim(expr_matrix)
# Should be: [number of genes, number of samples] (e.g., 20530 x 576)

# Check names
head(rownames(expr_matrix))   # should be gene symbols
head(colnames(expr_matrix))   # should be sample IDs

```

```{r}
expr_df <- read.csv("data/processed/TCGA_LUAD_expression_matched.csv", row.names = 1, check.names = FALSE)
expr_matrix <- as.matrix(expr_df)
expr_matrix <- t(as.matrix(expr_df))
# Show the dimensions of the matrix
dim(expr_matrix)

# Show the first 6 row and column names
head(rownames(expr_matrix))
head(colnames(expr_matrix))

# Show a small piece of the matrix
expr_matrix[1:5, 1:5]


```

```{r}

```

```{r}
expr_matrix <- t(expr_matrix)
dim(expr_matrix)           # Should now be 20530 x 576
head(rownames(expr_matrix))# "ARHGEF10L" "HIF3A" ...
head(colnames(expr_matrix))# "tcga_69_7978_01" ...
```

```{r}
clinical_df <- read.csv("data/processed/TCGA_LUAD_clinical.csv", check.names = FALSE)

# Clean sample names in expression matrix
colnames(expr_matrix) <- gsub("-", "_", tolower(colnames(expr_matrix)))  # "TCGA-05-4244-01" ‚Üí "tcga_05_4244_01"

# Clean clinical_df$sampleID to match
clinical_df$sample_id <- gsub("-", "_", tolower(clinical_df$sampleID))   # Add cleaned ID column

# Optional: remove trailing _01, _11 if needed
clinical_df$sample_id <- gsub("_0[1-3]$", "", clinical_df$sample_id)
colnames(expr_matrix) <- gsub("_0[1-3]$", "", colnames(expr_matrix))
matched_samples <- intersect(colnames(expr_matrix), clinical_df$sample_id)
cat("‚úÖ Matched samples:", length(matched_samples), "\n")
# Subset expression matrix
expr_matrix <- expr_matrix[, matched_samples]

# Subset and filter clinical data
clinical_df <- clinical_df %>%
  filter(sample_id %in% matched_samples) %>%
  distinct(sample_id, .keep_all = TRUE)

```

```{r}
run_survival_analysis <- function(expr_matrix, clinical_df, gene_list,
                                  output_dir = "results", plot_dir = "figures") {
  # üìÅ Create output directories if not exist
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(plot_dir, showWarnings = FALSE, recursive = TRUE)

  # ‚úÖ Harmonize sample IDs
  colnames(expr_matrix) <- gsub("-", "_", tolower(colnames(expr_matrix)))
  clinical_df$sample_id <- gsub("-", "_", tolower(clinical_df$sampleID))
  colnames(expr_matrix) <- gsub("_0[1-9]$", "", colnames(expr_matrix))
  clinical_df$sample_id <- gsub("_0[1-9]$", "", clinical_df$sample_id)

  # ‚úÖ Match samples
  matched_samples <- intersect(colnames(expr_matrix), clinical_df$sample_id)
  cat("‚úÖ Matched samples:", length(matched_samples), "\n")

  # üîé Subset data
  expr_matrix <- expr_matrix[, matched_samples]
  clinical_df <- clinical_df %>%
    filter(sample_id %in% matched_samples) %>%
    distinct(sample_id, .keep_all = TRUE)

  results_list <- list()

  for (gene in gene_list) {
    message("üîç Processing gene: ", gene)

    if (!gene %in% rownames(expr_matrix)) {
      message("‚ùå Skipping ", gene, ": not in expression matrix.")
      next
    }

    expr_vec <- expr_matrix[gene, ]

    if (all(is.na(expr_vec)) || length(na.omit(expr_vec)) < 20 || sd(expr_vec, na.rm = TRUE) == 0) {
      message("‚ö†Ô∏è Skipping ", gene, ": not enough valid expression values.")
      next
    }

    expr_vec <- expr_vec[matched_samples]
    clin_gene <- clinical_df %>%
      filter(sample_id %in% matched_samples) %>%
      mutate(expr = expr_vec[match(sample_id, matched_samples)]) %>%
      filter(!is.na(expr))

    if (nrow(clin_gene) < 20) {
      message("‚ö†Ô∏è Skipping ", gene, ": fewer than 20 valid samples.")
      next
    }

    # Optimal cutpoint
    cut <- tryCatch({
      surv_cutpoint(clin_gene, time = "surv_time", event = "event", variables = "expr")
    }, error = function(e) {
      message("‚ùå Error in cutpoint for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(cut)) next

    group <- surv_categorize(cut)
    clin_gene$gene_group <- group$expr
    clin_gene$gender <- as.factor(clin_gene$gender)

    # Cox models
    cox_uni <- coxph(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    cox_multi <- tryCatch({
      coxph(Surv(surv_time, event) ~ gene_group + age_at_initial_pathologic_diagnosis + gender, data = clin_gene)
    }, error = function(e) {
      message("‚ùå Multivariate Cox error for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(cox_multi)) next

    results_list[[gene]] <- list(
      cutpoint = cut$cutpoint$expr,
      cox_uni = summary(cox_uni),
      cox_multi = summary(cox_multi)
    )

    # KM plot
    fit <- survfit(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    plot_file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
    plot_obj <- ggsurvplot(
      fit, data = clin_gene, pval = TRUE, risk.table = TRUE,
      legend.title = gene, legend.labs = c("Low", "High"),
      title = paste("Survival by", gene, "Expression"),
      palette = c("steelblue", "firebrick")
    )
    ggsave(filename = plot_file, plot = plot_obj$plot, width = 7, height = 5, dpi = 300)
  }

  if (length(results_list) == 0) {
    message("üö´ No valid genes passed survival filtering. Skipping forest plot.")
    return(NULL)
  }

  # Forest data
  forest_data <- do.call(rbind, lapply(names(results_list), function(gene) {
    row <- results_list[[gene]]$cox_multi$coefficients["gene_groupHigh", ]
    data.frame(
      gene = gene,
      HR = exp(row["coef"]),
      lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
      upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
      pvalue = row["Pr(>|z|)"]
    )
  }))

  write.csv(forest_data, file.path(output_dir, "cox_multivariate_summary.csv"), row.names = FALSE)

  # Forest plot
  forest_data <- forest_data[order(forest_data$HR, decreasing = TRUE), ]
  forest_data$gene <- factor(forest_data$gene, levels = forest_data$gene)

  forest_plot <- ggplot(forest_data, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
    geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
    coord_flip() +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue"),
                       labels = c("Significant", "Not Significant")) +
    labs(title = "Forest Plot: Multivariate Cox Models",
         subtitle = "Adjusted for age and gender",
         x = "Gene", y = "Hazard Ratio (HR)", color = "Significance") +
    geom_text(aes(label = sprintf("p=%.3f", pvalue)), hjust = -0.1, color = "black", size = 4) +
    theme_minimal(base_size = 14)

  ggsave(file.path(plot_dir, "cox_forest_plot.png"), forest_plot, width = 10, height = 6, dpi = 300)
  message("‚úÖ Forest plot saved.")

  return(results_list)
}

```

```{r}
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)

run_survival_analysis <- function(expr_matrix, clinical_df, gene_list,
                                  output_dir = "results", plot_dir = "figures") {
  # üìÇ Setup output directories
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(plot_dir, showWarnings = FALSE, recursive = TRUE)

  # üß† Track results
  results_list <- list()
  matched_samples <- intersect(colnames(expr_matrix), tolower(clinical_df$sample_id))
  message("‚úÖ Matched samples: ", length(matched_samples))

  # üìå Validate required columns
  required_cols <- c("sample_id", "surv_time", "event", "age_at_initial_pathologic_diagnosis", "gender")
  missing_cols <- setdiff(required_cols, colnames(clinical_df))
  if (length(missing_cols) > 0) stop("‚ùå Missing required columns: ", paste(missing_cols, collapse = ", "))

  for (gene in gene_list) {
    message("üîç Processing gene: ", gene)

    if (!gene %in% rownames(expr_matrix)) {
      message("‚ùå Skipping ", gene, ": not in expression matrix.")
      next
    }

    expr_vec <- expr_matrix[gene, ]
    if (all(is.na(expr_vec)) || length(na.omit(expr_vec)) < 10 || sd(expr_vec, na.rm = TRUE) == 0) {
      message("‚ö†Ô∏è Skipping ", gene, ": not enough valid expression values.")
      next
    }

    # üß¨ Merge expression and clinical for matched samples
    expr_vec <- expr_vec[matched_samples]
    clin_gene <- clinical_df %>%
      filter(tolower(sample_id) %in% matched_samples) %>%
      mutate(expr = expr_vec[match(tolower(sample_id), matched_samples)]) %>%
      filter(!is.na(expr))

    if (nrow(clin_gene) < 20) {
      message("‚ö†Ô∏è Skipping ", gene, ": fewer than 20 valid samples.")
      next
    }

    # ‚úÇÔ∏è Determine optimal cutpoint
    cut <- tryCatch({
      surv_cutpoint(clin_gene, time = "surv_time", event = "event", variables = "expr")
    }, error = function(e) {
      message("‚ùå Error in cutpoint for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(cut)) next

    group <- tryCatch({
      categorized <- surv_categorize(cut)
      factor(categorized$expr, levels = c("low", "high"))
    }, error = function(e) {
      message("‚ùå Error in categorizing for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(group)) next

    clin_gene$gene_group <- group
    clin_gene$gender <- as.factor(clin_gene$gender)

    # ‚öôÔ∏è Cox models
    cox_uni <- tryCatch({
      coxph(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    }, error = function(e) {
      message("‚ùå Univariate Cox error for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(cox_uni)) next

    cox_multi <- tryCatch({
      coxph(Surv(surv_time, event) ~ gene_group + age_at_initial_pathologic_diagnosis + gender, data = clin_gene)
    }, error = function(e) {
      message("‚ùå Multivariate Cox error for ", gene, ": ", e$message)
      return(NULL)
    })
    if (is.null(cox_multi)) next

    results_list[[gene]] <- list(
      cutpoint = cut$cutpoint$expr,
      cox_uni = summary(cox_uni),
      cox_multi = summary(cox_multi)
    )

    # üìà KM Plot
    fit <- survfit(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    plot_file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
    tryCatch({
      plot_obj <- ggsurvplot(
        fit,
        data = clin_gene,
        pval = TRUE,
        risk.table = TRUE,
        legend.title = gene,
        legend.labs = c("Low", "High"),
        title = paste("Survival by", gene, "Expression"),
        palette = c("steelblue", "firebrick"),
        font.main = c(16, "bold"),
        font.legend = 12,
        font.x = 12,
        font.y = 12
      )
      ggsave(filename = plot_file, plot = plot_obj$plot, width = 8, height = 6, dpi = 300)
      message("‚úÖ KM plot saved: ", plot_file)
    }, error = function(e) {
      message("‚ùå Failed to generate KM plot for ", gene, ": ", e$message)
    })
  }

  # üìä Forest Plot Summary
  if (length(results_list) == 0) {
    message("üö´ No valid genes passed survival filtering. Skipping forest plot.")
    return(NULL)
  }

  forest_data <- do.call(rbind, lapply(names(results_list), function(gene) {
    row <- results_list[[gene]]$cox_multi$coefficients["gene_grouphigh", ]
    data.frame(
      gene = gene,
      HR = exp(row["coef"]),
      lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
      upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
      pvalue = row["Pr(>|z|)"]
    )
  }))

  write.csv(forest_data, file.path(output_dir, "cox_multivariate_summary.csv"), row.names = FALSE)

  forest_data <- forest_data[order(forest_data$HR, decreasing = TRUE), ]
  forest_data$gene <- factor(forest_data$gene, levels = forest_data$gene)

  forest_plot <- ggplot(forest_data, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
    geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
    coord_flip() +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue"),
                       labels = c("Significant", "Not Significant")) +
    labs(
      title = "Multivariate Cox Model Forest Plot",
      subtitle = "Adjusted for Age & Gender",
      x = "Gene", y = "Hazard Ratio (HR)", color = "Significance"
    ) +
    geom_text(aes(label = sprintf("p=%.3f", pvalue)), hjust = -0.1, size = 4, color = "black") +
    theme_minimal(base_size = 14)

  ggsave(file.path(plot_dir, "cox_forest_plot.png"), forest_plot, width = 10, height = 6, dpi = 300)
  message("‚úÖ Forest plot saved: ", file.path(plot_dir, "cox_forest_plot.png"))

  return(results_list)
}


```

```{r}
clinical_df <- clinical_df %>%
  mutate(
    event = ifelse(tolower(vital_status) == "deceased", 1, 0),
    surv_time = ifelse(!is.na(days_to_death), days_to_death, days_to_last_followup)
  ) %>%
  filter(!is.na(surv_time), !is.na(event))
run_survival_analysis(
  expr_matrix = expr_matrix,
  clinical_df = clinical_df,
  gene_list = c("HIF3A", "EGFR", "KRAS", "CDKN2A", "AKT1", "MYC", "TP53"),
  output_dir = "results",
  plot_dir = "figures"
)


```

```{r}
# Load required libraries
library(ggplot2)
library(gridExtra)

# ‚úÖ Define the directory and gene list used
plot_dir <- "figures"
gene_list <- c("HIF3A", "EGFR", "KRAS", "CDKN2A", "AKT1", "MYC", "TP53")

# ‚úÖ Load and display each KM plot
km_plots <- lapply(gene_list, function(gene) {
  file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
  if (file.exists(file)) grid::rasterGrob(png::readPNG(file)) else NULL
})

# Filter NULLs (missing plots)
km_plots <- km_plots[!sapply(km_plots, is.null)]

# Display first 6 in a grid (or modify as needed)
gridExtra::grid.arrange(grobs = km_plots[1:min(6, length(km_plots))], ncol = 2)

```

```{r}
# üì¶ Load libraries
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)

# üöÄ Robust Survival Analysis Function
run_survival_analysis <- function(expr_matrix, clinical_df, gene_list,
                                  output_dir = "results", plot_dir = "figures") {
  # üìÇ Create directories
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(plot_dir, showWarnings = FALSE, recursive = TRUE)

  # ‚úÖ Match sample IDs
  matched_samples <- intersect(colnames(expr_matrix), tolower(clinical_df$sample_id))
  message("‚úÖ Matched samples: ", length(matched_samples))

  # üîç Validate clinical data
  required_cols <- c("sample_id", "surv_time", "event", "age_at_initial_pathologic_diagnosis", "gender")
  missing_cols <- setdiff(required_cols, colnames(clinical_df))
  if (length(missing_cols) > 0) stop("‚ùå Missing required columns: ", paste(missing_cols, collapse = ", "))

  results_list <- list()

  # üîÅ Loop through genes
  for (gene in gene_list) {
    message("üîç Processing gene: ", gene)
    if (!gene %in% rownames(expr_matrix)) {
      message("‚ùå Skipping ", gene, ": not in expression matrix.")
      next
    }

    expr_vec <- expr_matrix[gene, ]
    expr_vec <- expr_vec[matched_samples]

    clin_gene <- clinical_df %>%
      filter(tolower(sample_id) %in% matched_samples) %>%
      mutate(expr = expr_vec[match(tolower(sample_id), matched_samples)]) %>%
      filter(!is.na(expr))

    if (nrow(clin_gene) < 20 || sd(clin_gene$expr, na.rm = TRUE) == 0) {
      message("‚ö†Ô∏è Skipping ", gene, ": insufficient variability or samples.")
      next
    }

    # ‚úÇÔ∏è Median expression split
    median_val <- median(clin_gene$expr, na.rm = TRUE)
    clin_gene$gene_group <- factor(ifelse(clin_gene$expr > median_val, "high", "low"), levels = c("low", "high"))
    clin_gene$gender <- as.factor(clin_gene$gender)

    # üî¨ Cox models
    cox_uni <- tryCatch(
      coxph(Surv(surv_time, event) ~ gene_group, data = clin_gene),
      error = function(e) { message("‚ùå Univariate Cox error for ", gene, ": ", e$message); NULL }
    )
    if (is.null(cox_uni)) next

    cox_multi <- tryCatch(
      coxph(Surv(surv_time, event) ~ gene_group + age_at_initial_pathologic_diagnosis + gender, data = clin_gene),
      error = function(e) { message("‚ùå Multivariate Cox error for ", gene, ": ", e$message); NULL }
    )
    if (is.null(cox_multi)) next

    results_list[[gene]] <- list(
      median = median_val,
      cox_uni = summary(cox_uni),
      cox_multi = summary(cox_multi)
    )

    # üìà Kaplan‚ÄìMeier plot
    fit <- survfit(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    plot_file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
    tryCatch({
      km_plot <- ggsurvplot(
        fit, data = clin_gene,
        pval = TRUE,
        risk.table = TRUE,
        legend.title = gene,
        legend.labs = c("Low", "High"),
        title = paste("Survival by", gene, "Expression"),
        palette = c("steelblue", "firebrick"),
        font.main = c(16, "bold"), font.legend = 12, font.x = 12, font.y = 12
      )
      ggsave(filename = plot_file, plot = km_plot$plot, width = 8, height = 6, dpi = 300)
      message("‚úÖ KM plot saved: ", plot_file)
    }, error = function(e) {
      message("‚ùå Failed KM plot for ", gene, ": ", e$message)
    })
  }

  # üß† Forest plot summary
  if (length(results_list) == 0) {
    message("üö´ No valid Cox multivariate results to plot or export.")
    return(NULL)
  }

  forest_data <- do.call(rbind, lapply(names(results_list), function(gene) {
    row <- results_list[[gene]]$cox_multi$coefficients["gene_grouphigh", ]
    data.frame(
      gene = gene,
      HR = exp(row["coef"]),
      lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
      upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
      pvalue = row["Pr(>|z|)"]
    )
  }))

  # üßæ Save summary table
  write.csv(forest_data, file.path(output_dir, "cox_multivariate_summary.csv"), row.names = FALSE)

  # üå≤ Forest plot
  forest_data <- forest_data[order(forest_data$HR, decreasing = TRUE), ]
  forest_data$gene <- factor(forest_data$gene, levels = forest_data$gene)

  forest_plot <- ggplot(forest_data, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
    geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
    coord_flip() +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue"),
                       labels = c("Significant", "Not Significant")) +
    geom_text(aes(label = sprintf("p=%.3f", pvalue)), hjust = -0.1, color = "black", size = 4) +
    labs(
      title = "Multivariate Cox Model Forest Plot",
      subtitle = "Adjusted for Age & Gender",
      x = "Gene", y = "Hazard Ratio (HR)", color = "Significance"
    ) +
    theme_minimal(base_size = 14)

  ggsave(file.path(plot_dir, "cox_forest_plot.png"), forest_plot, width = 10, height = 6, dpi = 300)
  message("‚úÖ Forest plot saved: ", file.path(plot_dir, "cox_forest_plot.png"))

  return(results_list)
}

```

```{r}
run_survival_analysis(
  expr_matrix = expr_matrix,
  clinical_df = clinical_df,
  gene_list = c("MYC"),
  output_dir = "results",
  plot_dir = "figures"
)

```

```{r}
sub_expr <- expr_matrix[c("HIF3A", "RNF17"), ]
write.csv(sub_expr, "HIF3A_RNF17_expression.csv")
boxplot(as.numeric(expr_matrix["HIF3A", ]), main="HIF3A expression")
sub_expr_t <- t(sub_expr)  # Now: samples as rows, genes as columns
head(sub_expr_t)
```

```{r}

library(dplyr)
library(tibble)

# Transpose and convert
clinical_df_tidy <- clinical_df %>%
  column_to_rownames(var = "sample") %>%  # make "sample" the rownames
  t() %>%                                 # transpose
  as.data.frame() %>%
  rownames_to_column(var = "sample_id")   # bring rownames back as a column
head(clinical_df_tidy)
colnames(clinical_df_tidy)

```

```{r}
clinical_df <- read.csv("path/to/TCGA_LUAD_clinical.csv")

```

```{r}
dim(expr_matrix_qc)  # rows = genes, cols = TCGA barcodes
matched_samples <- intersect(clinical_data_clean$sample_id, colnames(expr_matrix_qc))

expr_matrix_qc <- expr_matrix_qc[, matched_samples]
clinical_data_clean <- clinical_data_clean %>%
  filter(sample_id %in% matched_samples) %>%
  arrange(match(sample_id, colnames(expr_matrix_qc)))  # align order

```

```{r}
head(colnames(expr_matrix_qc), 10)
head(clinical_data_clean$sample_id, 10)


```

```{r}
clinical_data <- readRDS("TCGA_LUAD_Clinical.rds")
# Reload original clinical file
clinical_data <- readRDS("TCGA_LUAD_Clinical.rds")

# Inspect for TCGA IDs
colnames(clinical_data)
# Likely candidate: 'submitter_id' or 'bcr_patient_barcode'

# Now clean it properly
clinical_data_clean <- clinical_data %>%
  rename(sample_id = submitter_id) %>%  # Change if needed to correct column
  mutate(
    sample_id = toupper(sample_id),
    sample_id = gsub("_", "-", sample_id),
    sample_id = sub("-01$", "", sample_id),
    sample_id = sub("-11$", "", sample_id)
  ) %>%
  mutate(
    event = ifelse(vital_status == "Dead", 1,
                   ifelse(vital_status == "Alive", 0, NA)),
    surv_time = ifelse(!is.na(days_to_death), days_to_death, days_to_last_follow_up)
  ) %>%
  filter(!is.na(event) & !is.na(surv_time)) %>%
  select(sample_id, event, surv_time, gender, age_at_diagnosis) %>%
  rename(age_at_initial_pathologic_diagnosis = age_at_diagnosis)

# ‚úÖ Check again
length(clinical_data_clean$sample_id)
head(clinical_data_clean$sample_id)

```

```{r}
# Clean expression barcodes
colnames(expr_matrix_qc) <- gsub("_", "-", toupper(colnames(expr_matrix_qc)))
colnames(expr_matrix_qc) <- sub("-01$", "", colnames(expr_matrix_qc))
colnames(expr_matrix_qc) <- sub("-11$", "", colnames(expr_matrix_qc))

# Match
matched_samples <- intersect(colnames(expr_matrix_qc), clinical_data_clean$sample_id)
length(matched_samples)  # ‚úÖ Expect ~567

```

```{r}
clinical_data_clean <- clinical_data %>%
  rename(sample_id = bcr_patient_barcode) %>%
  mutate(
    sample_id = toupper(sample_id),  # just in case
    sample_id = gsub("_", "-", sample_id),
    sample_id = sub("-01$", "", sample_id),
    sample_id = sub("-11$", "", sample_id),
    event = ifelse(tolower(vital_status) == "dead", 1,
                   ifelse(tolower(vital_status) == "alive", 0, NA)),
    surv_time = ifelse(!is.na(days_to_death), days_to_death, days_to_last_follow_up)
  ) %>%
  filter(!is.na(event) & !is.na(surv_time)) %>%
  select(sample_id, event, surv_time, gender, age_at_diagnosis) %>%
  rename(age_at_initial_pathologic_diagnosis = age_at_diagnosis)
# Clean colnames of expression matrix
colnames(expr_matrix_qc) <- gsub("_", "-", toupper(colnames(expr_matrix_qc)))
colnames(expr_matrix_qc) <- sub("-01$", "", colnames(expr_matrix_qc))
colnames(expr_matrix_qc) <- sub("-11$", "", colnames(expr_matrix_qc))

# Match samples
matched_samples <- intersect(colnames(expr_matrix_qc), clinical_data_clean$sample_id)
length(matched_samples)  # ‚úÖ Should now be ~507


```

```{r}
# üì¶ Load libraries
library(survival)
library(survminer)
library(dplyr)
library(ggplot2)

# üöÄ Robust Survival Analysis Function
run_survival_analysis <- function(expr_matrix, clinical_df, gene_list,
                                  output_dir = "results", plot_dir = "figures") {
  # üìÇ Create directories
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  dir.create(plot_dir, showWarnings = FALSE, recursive = TRUE)

  # ‚úÖ Match sample IDs
  matched_samples <- intersect(colnames(expr_matrix), tolower(clinical_df$sample_id))
  message("‚úÖ Matched samples: ", length(matched_samples))

  # üîç Validate clinical data
  required_cols <- c("sample_id", "surv_time", "event", "age_at_initial_pathologic_diagnosis", "gender")
  missing_cols <- setdiff(required_cols, colnames(clinical_df))
  if (length(missing_cols) > 0) stop("‚ùå Missing required columns: ", paste(missing_cols, collapse = ", "))

  results_list <- list()

  # üîÅ Loop through genes
  for (gene in gene_list) {
    message("üîç Processing gene: ", gene)
    if (!gene %in% rownames(expr_matrix)) {
      message("‚ùå Skipping ", gene, ": not in expression matrix.")
      next
    }

    expr_vec <- expr_matrix[gene, ]
    expr_vec <- expr_vec[matched_samples]

    clin_gene <- clinical_df %>%
      filter(tolower(sample_id) %in% matched_samples) %>%
      mutate(expr = expr_vec[match(tolower(sample_id), matched_samples)]) %>%
      filter(!is.na(expr))

    if (nrow(clin_gene) < 20 || sd(clin_gene$expr, na.rm = TRUE) == 0) {
      message("‚ö†Ô∏è Skipping ", gene, ": insufficient variability or samples.")
      next
    }

    # ‚úÇÔ∏è Median expression split
    median_val <- median(clin_gene$expr, na.rm = TRUE)
    clin_gene$gene_group <- factor(ifelse(clin_gene$expr > median_val, "high", "low"), levels = c("low", "high"))
    clin_gene$gender <- as.factor(clin_gene$gender)

    # üî¨ Cox models
    cox_uni <- tryCatch(
      coxph(Surv(surv_time, event) ~ gene_group, data = clin_gene),
      error = function(e) { message("‚ùå Univariate Cox error for ", gene, ": ", e$message); NULL }
    )
    if (is.null(cox_uni)) next

    cox_multi <- tryCatch(
      coxph(Surv(surv_time, event) ~ gene_group + age_at_initial_pathologic_diagnosis + gender, data = clin_gene),
      error = function(e) { message("‚ùå Multivariate Cox error for ", gene, ": ", e$message); NULL }
    )
    if (is.null(cox_multi)) next

    results_list[[gene]] <- list(
      median = median_val,
      cox_uni = summary(cox_uni),
      cox_multi = summary(cox_multi)
    )

    # üìà Kaplan‚ÄìMeier plot
    fit <- survfit(Surv(surv_time, event) ~ gene_group, data = clin_gene)
    plot_file <- file.path(plot_dir, paste0("KM_", gene, ".png"))
    tryCatch({
      km_plot <- ggsurvplot(
        fit, data = clin_gene,
        pval = TRUE,
        risk.table = TRUE,
        legend.title = gene,
        legend.labs = c("Low", "High"),
        title = paste("Survival by", gene, "Expression"),
        palette = c("steelblue", "firebrick"),
        font.main = c(16, "bold"), font.legend = 12, font.x = 12, font.y = 12
      )
      ggsave(filename = plot_file, plot = km_plot$plot, width = 8, height = 6, dpi = 300)
      message("‚úÖ KM plot saved: ", plot_file)
    }, error = function(e) {
      message("‚ùå Failed KM plot for ", gene, ": ", e$message)
    })
  }

  # üß† Forest plot summary
  if (length(results_list) == 0) {
    message("üö´ No valid Cox multivariate results to plot or export.")
    return(NULL)
  }

  forest_data <- do.call(rbind, lapply(names(results_list), function(gene) {
    row <- results_list[[gene]]$cox_multi$coefficients["gene_grouphigh", ]
    data.frame(
      gene = gene,
      HR = exp(row["coef"]),
      lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
      upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
      pvalue = row["Pr(>|z|)"]
    )
  }))

  # üßæ Save summary table
  write.csv(forest_data, file.path(output_dir, "cox_multivariate_summary.csv"), row.names = FALSE)

  # üå≤ Forest plot
  forest_data <- forest_data[order(forest_data$HR, decreasing = TRUE), ]
  forest_data$gene <- factor(forest_data$gene, levels = forest_data$gene)

  forest_plot <- ggplot(forest_data, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
    geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
    coord_flip() +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue"),
                       labels = c("Significant", "Not Significant")) +
    geom_text(aes(label = sprintf("p=%.3f", pvalue)), hjust = -0.1, color = "black", size = 4) +
    labs(
      title = "Multivariate Cox Model Forest Plot",
      subtitle = "Adjusted for Age & Gender",
      x = "Gene", y = "Hazard Ratio (HR)", color = "Significance"
    ) +
    theme_minimal(base_size = 14)

  ggsave(file.path(plot_dir, "cox_forest_plot.png"), forest_plot, width = 10, height = 6, dpi = 300)
  message("‚úÖ Forest plot saved: ", file.path(plot_dir, "cox_forest_plot.png"))

  return(results_list)
}
save(results_list, file = "results/cox_results_list.RData")

```

```{r}
list.files("figures", pattern = "KM_.*\\.png$")
file.exists("figures/cox_forest_plot.png")
file.exists("results/cox_multivariate_summary.csv")

```

```{r}
results_list <- run_survival_analysis(
  expr_matrix = expr_matrix,
  clinical_df = clinical_df,
  gene_list = c("MYC", "EGFR", "KRAS", "TP53", "AKT1", "CDKN2A", "HIF3A"),
  output_dir = "results",
  plot_dir = "figures"
)

```

```{r}
names(results_list)
read.csv("results/cox_multivariate_summary.csv")

```

```{r}
km_files <- list.files("figures", pattern = "KM_.*\\.png$", full.names = TRUE)
lapply(km_files, browseURL)

```

```{r}
# View one image
shell.exec("figures/KM_TP53.png")  # Only works on Windows

# On macOS use:
system("open figures/KM_TP53.png")

# On Linux:
system("xdg-open figures/KM_TP53.png")

```

```{r}
cox_summary <- read.csv("results/cox_multivariate_summary.csv")
print(cox_summary)

```

```{r}
km_files <- list.files("figures", pattern = "KM_.*\\.png$", full.names = TRUE)

for (file in km_files) {
  print(paste("üìà Viewing:", file))
  img <- png::readPNG(file)
  grid::grid.raster(img)
}

```

```{r}
save(results_list, file = "results/cox_results_list.RData")
load("results/cox_results_list.RData")

# Confirm
names(results_list)


```

```{r}
results_list[["MYC"]]$cox_multi

```

```{r}
forest_table <- do.call(rbind, lapply(names(results_list), function(gene) {
  row <- results_list[[gene]]$cox_multi$coefficients["gene_grouphigh", ]
  data.frame(
    gene = gene,
    HR = exp(row["coef"]),
    lower95 = exp(row["coef"] - 1.96 * row["se(coef)"]),
    upper95 = exp(row["coef"] + 1.96 * row["se(coef)"]),
    pvalue = row["Pr(>|z|)"]
  )
}))
print(forest_table)

```

```{r}
library(ggplot2)
forest_table <- forest_table[order(forest_table$HR, decreasing = TRUE), ]
forest_table$gene <- factor(forest_table$gene, levels = forest_table$gene)

ggplot(forest_table, aes(x = gene, y = HR, ymin = lower95, ymax = upper95)) +
  geom_pointrange(aes(color = pvalue < 0.05), fatten = 3, size = 1.2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray") +
  coord_flip() +
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
  labs(
    title = "Forest Plot from Saved Cox Results",
    x = "Gene", y = "Hazard Ratio (HR)", color = "Significance"
  ) +
  theme_minimal(base_size = 14)

```

##STRING PPI Network

```{r}
# ‚úÖ Create the STRING cache directory if it doesn't exist
dir.create("STRING_cache", showWarnings = FALSE, recursive = TRUE)

# üîÅ Initialize STRINGdb
string_db <- STRINGdb$new(
  version = "11.5",
  species = 9606,
  score_threshold = 400,
  input_directory = "STRING_cache"
)


# Load package
library(STRINGdb)
# Your top survival-associated genes
top_genes <- c("MYC", "EGFR", "KRAS", "TP53", "AKT1", "CDKN2A", "HIF3A")

# Create a data frame for mapping
gene_df <- data.frame(gene = top_genes, stringsAsFactors = FALSE)
string_db <- STRINGdb$new(
  version = "11.5",  # or latest version
  species = 9606,    # NCBI tax ID for Homo sapiens
  score_threshold = 400,
  input_directory = "STRING_cache"
)
# Map gene symbols to STRING identifiers
mapped_df <- string_db$map(gene_df, "gene", removeUnmappedRows = TRUE)

# Show mapped genes
print(mapped_df)

```

```{r}
# üìå Make sure the mapped_df exists (you already have it)
# Check structure
print(mapped_df)

# üìà Plot the network
string_db$plot_network(mapped_df$STRING_id)

# üíæ Save the plot as a PNG
png("figures/ppi_survival_genes.png", width = 1000, height = 800, res = 150)
string_db$plot_network(mapped_df$STRING_id)
dev.off()

message("‚úÖ PPI plot saved as: figures/ppi_survival_genes.png")
ppi_table <- string_db$get_interactions(mapped_df$STRING_id)
write.csv(ppi_table, "results/ppi_interactions.csv", row.names = FALSE)

```

```{r}
library(igraph)

# Get interaction data
ppi_edges <- string_db$get_interactions(mapped_df$STRING_id)

# Build igraph object
ppi_graph <- graph_from_data_frame(ppi_edges[, c("from", "to")], directed = FALSE)

# Plot
plot(ppi_graph,
     vertex.label = mapped_df$gene,
     vertex.size = 25,
     vertex.color = "lightblue",
     edge.color = "gray50",
     edge.width = 1.5,
     layout = layout_in_circle,
     main = "Survival-Associated Gene Interactions (STRING)")

```

```{r}
degree_vals <- degree(ppi_graph)
V(ppi_graph)$color <- ifelse(degree_vals > 4, "orange", "lightblue")

plot(ppi_graph,
     vertex.label = mapped_df$gene,
     vertex.label.cex = 1.2,
     vertex.size = 25,
     vertex.color = V(ppi_graph)$color,
     edge.width = 1.5,
     layout = layout_with_fr,
     main = "PPI Network Highlighting Hub Genes")


```

```{r}
# üéØ Assume you already have this from survival Cox analysis
hr_table <- data.frame(
  gene = c("MYC", "EGFR", "KRAS", "TP53", "AKT1", "CDKN2A", "HIF3A"),
  HR = c(1.1071, 1.0406, 1.2749, 0.9986, 0.9369, 1.1347, 1.0976),
  pvalue = c(0.500, 0.793, 0.109, 0.992, 0.666, 0.399, 0.536)
)

# üéØ Merge with STRING ID mapping
ppi_annot <- mapped_df %>%
  inner_join(hr_table, by = "gene")

# üéØ Ensure only those in the actual graph are used
ppi_annot <- ppi_annot[ppi_annot$STRING_id %in% V(ppi_graph)$name, ]

# üß† Assign node attributes in the graph
V(ppi_graph)$HR <- ppi_annot$HR[match(V(ppi_graph)$name, ppi_annot$STRING_id)]
V(ppi_graph)$pvalue <- ppi_annot$pvalue[match(V(ppi_graph)$name, ppi_annot$STRING_id)]

# üé® Color: Red if p < 0.05, else grey
V(ppi_graph)$color <- ifelse(V(ppi_graph)$pvalue < 0.05, "red", "lightgrey")

# üéØ Size by HR (capped for aesthetics)
V(ppi_graph)$size <- scales::rescale(pmin(V(ppi_graph)$HR, 2), to = c(20, 40))

# üñºÔ∏è Plot with enriched info
plot(ppi_graph,
     vertex.label = ppi_annot$gene,
     vertex.color = V(ppi_graph)$color,
     vertex.size = V(ppi_graph)$size,
     edge.width = 1.5,
     layout = layout_with_fr,
     main = "STRING PPI with HR & p-value overlay")

legend("bottomleft", legend = c("Significant (p<0.05)", "Not significant"),
       fill = c("red", "lightgrey"), bty = "n")

```

```{r}
# üåê Node table
cyto_nodes <- data.frame(
  id = V(ppi_graph)$name,
  gene_symbol = ppi_annot$gene[match(V(ppi_graph)$name, ppi_annot$STRING_id)],
  HR = V(ppi_graph)$HR,
  pvalue = V(ppi_graph)$pvalue
)

# üåê Edge table
cyto_edges <- igraph::as_data_frame(ppi_graph, what = "edges")

# üíæ Save files
write.csv(cyto_nodes, "results/cytoscape_nodes.csv", row.names = FALSE)
write.csv(cyto_edges, "results/cytoscape_edges.csv", row.names = FALSE)

```

```{r}
list.files("C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project", full.names = TRUE)

```

```{r}
# ‚úÖ Correct working code
tpm_file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/expr_tpm_cleaned_hgnc.csv"

if (!file.exists(tpm_file)) {
  stop(paste("‚ùå Expression file not found at:", tpm_file))
}

expr <- read.csv(tpm_file, row.names = 1, check.names = FALSE)
message("‚úÖ Expression matrix loaded.")
expr <- as.matrix(expr)

```

```{r}
# Inspect dimensions
cat("üìè Dimensions of the matrix:\n")
dim(expr)

# View first few rows and columns
cat("\nüëÄ Preview of the expression matrix:\n")
print(expr[1:5, 1:5])

# Check for NA values
cat("\nüîç Checking for NA values:\n")
sum(is.na(expr))

# Check value ranges
cat("\nüìä Summary of expression values:\n")
summary(as.vector(expr))

# Check if rownames (genes) and colnames (samples) are present
cat("\nüî§ Row names (genes) and column names (samples) check:\n")
print(head(rownames(expr)))
print(head(colnames(expr)))

# Check for duplicated gene names
cat("\n‚ö†Ô∏è Checking for duplicated gene symbols:\n")
sum(duplicated(rownames(expr)))

# Optional: plot a histogram of expression values
hist(expr, main = "Histogram of Expression Values",
     xlab = "TPM Expression", col = "skyblue", breaks = 50)

```

```{r}
# Load required package
library(biomaRt)

# Connect to Ensembl
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Extract gene list
ensembl_ids <- rownames(expr)

# Map Ensembl ‚Üí HGNC
gene_map <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  values = ensembl_ids,
  mart = mart
)

# Remove empty symbols
gene_map <- gene_map[gene_map$hgnc_symbol != "", ]

# Deduplicate mapping
gene_map <- gene_map[!duplicated(gene_map$ensembl_gene_id), ]

# Subset and rename
expr_mapped <- expr[rownames(expr) %in% gene_map$ensembl_gene_id, ]
rownames(expr_mapped) <- gene_map$hgnc_symbol[match(rownames(expr_mapped), gene_map$ensembl_gene_id)]

# Check
cat("‚úÖ Expression matrix now has HGNC gene symbols.\n")
expr_mapped[1:5, 1:5]

```

```{r}
library(msigdbr)
library(dplyr)

kegg_sets <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "CP:KEGG_LEGACY"
) %>%
  dplyr::select(gs_name, gene_symbol) %>%
  split(x = .$gene_symbol, f = .$gs_name)

cat("‚úÖ KEGG gene sets loaded:", length(kegg_sets), "pathways\n")
```

```{r}

suppressPackageStartupMessages({
  library(GSVA)
  library(msigdbr)
  library(dplyr)
})
# Assuming expr is already loaded
expr_matrix <- as.matrix(expr)
stopifnot(is.numeric(expr_matrix[1, 1]))  # ‚úÖ ensures it's numeric


```

```{r}
kegg_sets <- msigdbr(
  species = "Homo sapiens",
  collection = "C2",
  subcollection = "CP:KEGG_LEGACY"
) %>%
  dplyr::select(gs_name, gene_symbol)
# Load biomaRt
if (!requireNamespace("biomaRt", quietly = TRUE)) BiocManager::install("biomaRt")
library(biomaRt)

# Connect to Ensembl (Human genes)
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Map Ensembl IDs to HGNC symbols
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = rownames(expr_matrix),
  mart = mart
)

# Remove empty mappings
mapping <- mapping[mapping$hgnc_symbol != "", ]

# Deduplicate by keeping only first mapping
mapping <- mapping[!duplicated(mapping$ensembl_gene_id), ]

# Subset expression matrix
expr_matrix_symbol <- expr_matrix[rownames(expr_matrix) %in% mapping$ensembl_gene_id, ]

# Replace Ensembl rownames with gene symbols
rownames(expr_matrix_symbol) <- mapping$hgnc_symbol[match(rownames(expr_matrix_symbol), mapping$ensembl_gene_id)]

# Optional: remove duplicates (if same gene symbol maps to multiple Ensembl IDs)
expr_matrix_symbol <- expr_matrix_symbol[!duplicated(rownames(expr_matrix_symbol)), ]

cat("‚úÖ Expression matrix now has HGNC gene symbols. Dimensions:", dim(expr_matrix_symbol), "\n")

```

```{r}
# KEGG (legacy) gene sets
kegg_sets <- msigdbr(
  species = "Homo sapiens",
  collection = "C2",
  subcollection = "CP:KEGG_LEGACY"
) %>%
  dplyr::select(gs_name, gene_symbol)

# Filter pathways based on available genes
filtered_kegg_sets <- kegg_sets %>%
  filter(gene_symbol %in% rownames(expr_matrix_symbol)) %>%
  split(x = .$gene_symbol, f = .$gs_name)

cat("‚úÖ Filtered KEGG gene sets:", length(filtered_kegg_sets), "pathways\n")

```

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install("GSVA", force = TRUE)

```

```{r}
GSVA::gsva

```

```{r}
# Load required libraries
suppressPackageStartupMessages({
  library(GSVA)
  library(msigdbr)
  library(dplyr)
})

# üìÇ Load expression matrix
expr_matrix_symbol <- as.matrix(read.csv(
  "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/expr_tpm_cleaned_hgnc.csv",
  row.names = 1,
  check.names = FALSE
))

# ‚úÖ Step 1: Get KEGG LEGACY gene sets
kegg_sets <- msigdbr(
  species = "Homo sapiens",
  collection = "C2",
  subcollection = "CP:KEGG_LEGACY"
) %>%
  dplyr::select(gs_name, gene_symbol) %>%
  split(x = .$gene_symbol, f = .$gs_name)

cat("‚úÖ KEGG LEGACY gene sets loaded:", length(kegg_sets), "pathways\n")

# ‚úÖ Step 2: Filter KEGG gene sets to genes in expression matrix
filtered_kegg_sets <- lapply(kegg_sets, function(g) intersect(g, rownames(expr_matrix_symbol)))
filtered_kegg_sets <- filtered_kegg_sets[lengths(filtered_kegg_sets) >= 10]

cat("‚úÖ Filtered KEGG gene sets:", length(filtered_kegg_sets), "pathways with genes in expression matrix\n")

# ‚úÖ Step 3: Run GSVA
gsva_scores <- gsva(
  expr = expr_matrix_symbol,
  gset.idx.list = filtered_kegg_sets,
  method = "gsva",
  kcdf = "Gaussian",
  parallel.sz = 1
)

# ‚úÖ Step 4: Save results
write.csv(gsva_scores, "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/gsva_kegg_scores.csv")
cat("‚úÖ GSVA completed. Matrix dimensions:", dim(gsva_scores)[1], "pathways √ó", dim(gsva_scores)[2], "samples\n")

```

```{r}
if (!requireNamespace("biomaRt", quietly = TRUE)) install.packages("biomaRt")
library(biomaRt)

ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")

converted <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = gsub("\\..*", "", rownames(expr_matrix_symbol)),
  mart = ensembl
)

# Filter for non-empty gene symbols
converted <- converted[converted$hgnc_symbol != "", ]

# Collapse duplicate mappings (first hit)
converted_unique <- converted[!duplicated(converted$ensembl_gene_id), ]
rownames(expr_matrix_symbol) <- gsub("\\..*", "", rownames(expr_matrix_symbol))
expr_matrix_symbol <- expr_matrix_symbol[rownames(expr_matrix_symbol) %in% converted_unique$ensembl_gene_id, ]
rownames(expr_matrix_symbol) <- converted_unique$hgnc_symbol[match(rownames(expr_matrix_symbol), converted_unique$ensembl_gene_id)]

message("‚úÖ Expression matrix now converted to HGNC gene symbols")

head(rownames(expr_matrix_symbol), 10)

```

```{r}
filtered_kegg_sets <- lapply(kegg_sets, function(g) intersect(g, rownames(expr_matrix_symbol)))
filtered_kegg_sets <- filtered_kegg_sets[lengths(filtered_kegg_sets) >= 10]

cat("‚úÖ Filtered KEGG gene sets:", length(filtered_kegg_sets), "pathways with genes in expression matrix\n")

```

```{r}
library(msigdbr)
library(dplyr)

# ‚úÖ Load KEGG LEGACY gene sets
kegg_sets <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "CP:KEGG_LEGACY"
) %>%
  dplyr::select(gs_name, gene_symbol) %>%
  split(x = .$gene_symbol, f = .$gs_name)

cat("‚úÖ KEGG LEGACY gene sets loaded:", length(kegg_sets), "pathways\n")

```

```{r}
# Filter gene sets to retain only those with genes in your expression matrix
filtered_kegg_sets <- lapply(kegg_sets, function(genes) intersect(genes, rownames(expr_matrix_symbol)))
filtered_kegg_sets <- filtered_kegg_sets[lengths(filtered_kegg_sets) >= 10]

cat("‚úÖ Filtered KEGG gene sets:", length(filtered_kegg_sets), "pathways with genes in expression matrix\n")

```

```{r}
# Make sure these are properly formatted
class(expr_matrix_symbol)
dim(expr_matrix_symbol)
head(rownames(expr_matrix_symbol))  # Should have gene symbols
class(filtered_kegg_sets)
length(filtered_kegg_sets)
```

```{r}

# Load or create your matrix here!
# Example (replace with your actual code):
expr_matrix <- expr_matrix_symbol # if you mapped to HGNC symbols earlier

# Double check
print(head(rownames(expr_matrix)))
print(dim(expr_matrix))
```

```{r}
if (!requireNamespace("BiocManager", quietly=TRUE)) install.packages("BiocManager")
BiocManager::install("GSVA")
```

```{r}
sessionInfo()
find("gsva")
getAnywhere(gsva)
```

```{r}
library(GSVA)

param <- gsvaParam(
  exprData = expr_matrix,
  geneSets = filtered_kegg_sets,
  kcdf = "Gaussian"
)
gsva_scores <- gsva(param)
```

```{r}
any(duplicated(rownames(expr_matrix)))
# If TRUE, you have duplicates
rownames(expr_matrix)[duplicated(rownames(expr_matrix))]
expr_matrix <- expr_matrix[!duplicated(rownames(expr_matrix)), ]
```

```{r}
library(GSVA)
param <- gsvaParam(exprData = expr_matrix, geneSets = filtered_kegg_sets, kcdf = "Gaussian")
gsva_scores <- gsva(param)
```

```{r}
dim(gsva_scores)
head(gsva_scores)
```

```{r}
summary(gsva_scores["KEGG_ABC_TRANSPORTERS", ])
```

```{r}
boxplot(gsva_scores["KEGG_ABC_TRANSPORTERS", ], main="GSVA score distribution for ABC transporters")
```

```{r}
library(pheatmap)
pheatmap(gsva_scores)
```

```{r}
getwd()
list.files()
```

```{r}
write.csv(gsva_scores, file="gsva_scores.csv")
```

```{r}
clin <- readRDS("TCGA_LUAD_Clinical.rds")
str(clin)
head(clin)
```

```{r}
meta <- read.csv("TCGA_LUAD_expression_percentile.csv", stringsAsFactors = FALSE)
str(meta)
head(meta)
```

```{r}
clin <- readRDS("TCGA_LUAD_Clinical.rds")
head(clin)
colnames(clin)
```

```{r}
# Load your GSVA results (or expression data) if not already loaded
# gsva_scores <- read.csv("gsva_scores.csv", row.names=1)  # example

# Your clinical data
clin <- readRDS("TCGA_LUAD_Clinical.rds")

# Get the sample IDs from your GSVA matrix
sample_ids <- colnames(gsva_scores)

# Create the group vector (e.g., cancer stage)
group <- clin$ajcc_pathologic_stage[match(sample_ids, clin$bcr_patient_barcode)]
```

```{r}
table(group, useNA="ifany")
```

```{r}
valid <- !is.na(group)
boxplot(gsva_scores["KEGG_ABC_TRANSPORTERS", valid] ~ group[valid])
```

```{r}
subset <- group %in% c("Stage IA", "Stage IB")
boxplot(gsva_scores["KEGG_ABC_TRANSPORTERS", subset] ~ group[subset])
t.test(gsva_scores["KEGG_ABC_TRANSPORTERS", group == "Stage IA"],
       gsva_scores["KEGG_ABC_TRANSPORTERS", group == "Stage IB"])
```

```{r}
# üì¶ Load dependencies
library(dplyr)

# üìÇ File paths
root_dir <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project"
gsva_file <- file.path(root_dir, "gsva_scores.csv")
clin_file <- file.path(root_dir, "TCGA_LUAD_Clinical.rds")

# ‚úÖ Check if files exist
stopifnot(file.exists(gsva_file), file.exists(clin_file))
cat("‚úÖ All input files found.\n")

# üì• Load data
gsva_scores <- read.csv(gsva_file, row.names = 1, check.names = FALSE)
clinical_data <- readRDS(clin_file)

# ‚úÖ Inspect GSVA structure
cat("‚úÖ GSVA matrix dimensions:", dim(gsva_scores)[1], "pathways √ó", dim(gsva_scores)[2], "samples\n")
cat("üß™ First few column names (samples):\n")
print(head(colnames(gsva_scores)))

# üßº Clean GSVA sample names
colnames(gsva_scores) <- colnames(gsva_scores) %>%
  toupper() %>%
  gsub("_", "-", .) %>%
  sub("-01$", "", .) %>%
  sub("-11$", "", .)

# üßº Clean clinical sample names
clinical_data <- clinical_data %>%
  rename(sample_id = submitter_id) %>%
  mutate(
    sample_id = toupper(gsub("_", "-", sample_id)),
    sample_id = sub("-01$", "", sample_id),
    sample_id = sub("-11$", "", sample_id)
  ) %>%
  mutate(
    event = ifelse(tolower(vital_status) == "dead", 1,
                   ifelse(tolower(vital_status) == "alive", 0, NA)),
    surv_time = ifelse(!is.na(days_to_death), days_to_death, days_to_last_follow_up)
  ) %>%
  filter(!is.na(event), !is.na(surv_time)) %>%
  select(sample_id, event, surv_time, gender, age_at_diagnosis, ajcc_pathologic_stage) %>%
  rename(age = age_at_diagnosis, stage = ajcc_pathologic_stage) %>%
  distinct(sample_id, .keep_all = TRUE)

# üîó Match samples
matched_samples <- intersect(colnames(gsva_scores), clinical_data$sample_id)
cat("‚úÖ Matched samples:", length(matched_samples), "\n")

# üîç Final checks
gsva_scores <- gsva_scores[, matched_samples]
clinical_data <- clinical_data %>%
  filter(sample_id %in% matched_samples) %>%
  arrange(match(sample_id, matched_samples))

# üß™ Validate alignment
stopifnot(identical(colnames(gsva_scores), clinical_data$sample_id))
cat("üéØ Sample alignment successful. Ready for GSVA‚Äìclinical correlation analysis.\n")

# ‚úÖ Preview
head(clinical_data)
head(gsva_scores[, 1:5])


```

```{r}
# üì¶ Required libraries
library(ggplot2)
library(tidyr)
library(dplyr)
library(broom)

# üßº Ensure stage is factor
clinical_data$stage <- factor(clinical_data$stage)

# üìä Melt GSVA matrix to long format
gsva_long <- gsva_scores %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Pathway") %>%
  pivot_longer(-Pathway, names_to = "sample_id", values_to = "GSVA_score") %>%
  left_join(clinical_data, by = "sample_id") %>%
  filter(!is.na(stage))

# üî¨ Run ANOVA for each pathway
anova_results <- gsva_long %>%
  group_by(Pathway) %>%
  summarise(
    p_value = tryCatch(
      summary(aov(GSVA_score ~ stage))[[1]][["Pr(>F)"]][1],
      error = function(e) NA
    )
  ) %>%
  mutate(adj_p = p.adjust(p_value, method = "fdr")) %>%
  arrange(adj_p)

# ‚úÖ Save ANOVA results
write.csv(anova_results, file.path(root_dir, "results/gsva_stage_anova_results.csv"), row.names = FALSE)

# üé® Optional: Plot top 3 pathways with lowest p-value
top_pathways <- head(anova_results$Pathway, 3)

for (pathway in top_pathways) {
  plot_data <- filter(gsva_long, Pathway == pathway)
  p <- ggplot(plot_data, aes(x = stage, y = GSVA_score)) +
    geom_boxplot(fill = "steelblue", outlier.color = "red") +
    labs(title = paste("GSVA Score vs Stage:", pathway),
         x = "AJCC Stage", y = "GSVA Enrichment Score") +
    theme_minimal(base_size = 14)
  print(p)
}

```

```{r}
# üîß Convert GSVA matrix to numeric
gsva_scores <- read.csv(gsva_file, row.names = 1, check.names = FALSE)

# Ensure all values are numeric
gsva_scores <- as.data.frame(apply(gsva_scores, 2, as.numeric))
rownames(gsva_scores) <- read.csv(gsva_file, row.names = 1, check.names = FALSE) %>% rownames()
scores <- as.numeric(gsva_scores[pathway, ])

```

```{r}
# üì¶ Load libraries
library(survival)
library(survminer)
library(dplyr)

# üîß Ensure numeric GSVA matrix
gsva_scores <- read.csv(gsva_file, row.names = 1, check.names = FALSE)
gsva_scores <- as.data.frame(sapply(gsva_scores, as.numeric))
rownames(gsva_scores) <- rownames(read.csv(gsva_file, row.names = 1))

# üîç Filter top GSVA pathways by FDR
sig_cox <- cox_results %>% filter(FDR < 0.05) %>% arrange(FDR)
top_n <- 5
top_pathways <- head(sig_cox$Pathway, top_n)

# üìÅ Create output directory
plot_dir <- file.path(root_dir, "figures")
if (!dir.exists(plot_dir)) dir.create(plot_dir, recursive = TRUE)

# üîÅ Generate Kaplan‚ÄìMeier plots
for (pathway in top_pathways) {
  cat("üß¨ Processing:", pathway, "\n")
  
  # Extract GSVA scores
  scores <- as.numeric(gsva_scores[pathway, ])
  median_cutoff <- median(scores, na.rm = TRUE)
  group <- ifelse(scores > median_cutoff, "High", "Low")
  
  # Build dataset
  df <- clinical_data %>%
    mutate(
      GSVA_score = scores,
      GSVA_group = factor(group, levels = c("Low", "High"))
    )
  
  # Survival object and model
  surv_obj <- Surv(df$surv_time, df$event)
  fit <- survfit(surv_obj ~ GSVA_group, data = df)
  
  # Cox model for HR
  cox <- coxph(surv_obj ~ GSVA_group, data = df)
  cox_sum <- summary(cox)
  hr <- round(cox_sum$conf.int[1, "exp(coef)"], 2)
  ci_lower <- round(cox_sum$conf.int[1, "lower .95"], 2)
  ci_upper <- round(cox_sum$conf.int[1, "upper .95"], 2)
  pval <- signif(cox_sum$coefficients[1, "Pr(>|z|)"], 3)
  
  # üìà KM Plot
  title <- paste0(pathway, "\nHR=", hr, " (", ci_lower, "-", ci_upper, "), p=", pval)
  p <- ggsurvplot(
    fit,
    data = df,
    risk.table = TRUE,
    pval = TRUE,
    conf.int = TRUE,
    title = title,
    xlab = "Days",
    legend.labs = c("Low GSVA", "High GSVA"),
    palette = c("steelblue", "firebrick"),
    ggtheme = theme_minimal(base_size = 14)
  )
  
  # Save plot
  file_name <- paste0("KM_GSVA_", gsub("KEGG_", "", pathway), ".png")
  out_file <- file.path(plot_dir, file_name)
  ggsave(out_file, plot = p$plot, width = 7, height = 6, dpi = 300)
  cat("‚úÖ Saved:", out_file, "\n")
}

```

## Kaplan‚ÄìMeier Survival Analysis for Top GSVA Pathways

```{r km-gsva-plots, message=FALSE, warning=FALSE, fig.width=7, fig.height=6, fig.cap="Kaplan‚ÄìMeier survival plots of top GSVA pathways in LUAD patients (High vs Low GSVA groups split by median)."}

# üì¶ Load libraries
library(survival)
library(survminer)
library(dplyr)

# üîß Ensure GSVA matrix is numeric
gsva_scores <- read.csv(gsva_file, row.names = 1, check.names = FALSE)
gsva_scores <- as.data.frame(sapply(gsva_scores, as.numeric))
rownames(gsva_scores) <- rownames(read.csv(gsva_file, row.names = 1))

# üìä Filter significant pathways (FDR < 0.05)
sig_cox <- cox_results %>% filter(FDR < 0.05) %>% arrange(FDR)
top_n <- 3  # Show top 3 here to avoid clutter
top_pathways <- head(sig_cox$Pathway, top_n)

# üîÅ KM plots for top pathways
km_plots <- list()
for (pathway in top_pathways) {
  scores <- as.numeric(gsva_scores[pathway, ])
  median_cutoff <- median(scores, na.rm = TRUE)
  group <- ifelse(scores > median_cutoff, "High", "Low")
  
  df <- clinical_data %>%
    mutate(GSVA_score = scores,
           GSVA_group = factor(group, levels = c("Low", "High")))
  
  surv_obj <- Surv(df$surv_time, df$event)
  fit <- survfit(surv_obj ~ GSVA_group, data = df)
  
  cox <- coxph(surv_obj ~ GSVA_group, data = df)
  cox_sum <- summary(cox)
  hr <- round(cox_sum$conf.int[1, "exp(coef)"], 2)
  ci_lower <- round(cox_sum$conf.int[1, "lower .95"], 2)
  ci_upper <- round(cox_sum$conf.int[1, "upper .95"], 2)
  pval <- signif(cox_sum$coefficients[1, "Pr(>|z|)"], 3)
  
  title <- paste0(pathway, "\nHR = ", hr, " (", ci_lower, "-", ci_upper, "), p = ", pval)
  
  km <- ggsurvplot(
    fit,
    data = df,
    risk.table = TRUE,
    pval = TRUE,
    conf.int = TRUE,
    title = title,
    xlab = "Days",
    legend.labs = c("Low GSVA", "High GSVA"),
    palette = c("steelblue", "firebrick"),
    ggtheme = theme_minimal(base_size = 13)
  )
  
  km_plots[[pathway]] <- km$plot
}

# üñºÔ∏è Display plots in RMarkdown
for (p in km_plots) print(p)


```

```{r}
# üìä Select top significant
sig_cox <- cox_results %>% filter(FDR < 0.05)

# üå≤ Forest plot
library(ggplot2)

ggplot(sig_cox, aes(x = reorder(Pathway, HR), y = HR)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower95, ymax = upper95), width = 0.2) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  coord_flip() +
  labs(title = "Significant KEGG Pathways (GSVA) Associated with Survival",
       y = "Hazard Ratio (HR)", x = "Pathway") +
  theme_minimal(base_size = 14)

# ‚úÖ Save results
ggsave(file.path(root_dir, "figures/gsva_pathway_forest_plot.png"), width = 10, height = 6)
print(p)
```

```{r}
# üì¶ Load required
library(dplyr)

# ‚úÖ Define DNA repair-related KEGG pathways
repair_pathways <- c(
  "KEGG_HOMOLOGOUS_RECOMBINATION",
  "KEGG_NON_HOMOLOGOUS_END_JOINING",
  "KEGG_NUCLEOTIDE_EXCISION_REPAIR",
  "KEGG_BASE_EXCISION_REPAIR",
  "KEGG_MISMATCH_REPAIR"
)

# üß™ Check which of these are present in your gsva_scores matrix
available_pathways <- intersect(repair_pathways, rownames(gsva_scores))

if (length(available_pathways) == 0) {
  stop("‚ùå None of the specified DNA repair pathways are found in the GSVA matrix.")
} else {
  cat("‚úÖ Found the following DNA repair pathways:\n")
  print(available_pathways)
}

# üß¨ Extract relevant GSVA rows
repair_gsva <- gsva_scores[available_pathways, , drop = FALSE]

# üßÆ Compute mean composite score per sample
composite_score <- colMeans(repair_gsva, na.rm = TRUE)

# üéØ Match to clinical samples
matched_samples <- intersect(names(composite_score), clinical_data$sample_id)
clinical_data$DNA_Repair_Score <- composite_score[clinical_data$sample_id]

# ‚úÖ Summary check
summary(clinical_data$DNA_Repair_Score)

```

```{r}
# üß™ Stratify by median
group <- ifelse(clinical_data$DNA_Repair_Score > median(clinical_data$DNA_Repair_Score, na.rm=TRUE),
                "High", "Low")
clinical_data$DNA_Repair_Group <- factor(group, levels = c("Low", "High"))

# üìà KM Plot
library(survival)
library(survminer)

fit <- survfit(Surv(surv_time, event) ~ DNA_Repair_Group, data = clinical_data)
ggsurvplot(
  fit,
  data = clinical_data,
  pval = TRUE,
  conf.int = TRUE,
  risk.table = TRUE,
  title = "Kaplan‚ÄìMeier Plot: DNA Repair Composite GSVA Score",
  xlab = "Days",
  palette = c("steelblue", "firebrick"),
  legend.labs = c("Low GSVA", "High GSVA"),
  ggtheme = theme_minimal(base_size = 14)
)

```

```{r}
cox_fit <- coxph(Surv(surv_time, event) ~ DNA_Repair_Score + age + gender + stage, data = clinical_data)
summary(cox_fit)

```

## üß¨ DNA Repair Composite GSVA Score and Survival Analysis

```{r dna-repair-gsva-analysis, message=FALSE, warning=FALSE, fig.width=7, fig.height=6, fig.cap="Kaplan‚ÄìMeier survival plot for LUAD patients stratified by composite GSVA score of DNA repair pathways."}

# üì¶ Load required libraries
library(dplyr)
library(survival)
library(survminer)

# üî¨ Step 1: Define DNA Repair Pathways
repair_pathways <- c(
  "KEGG_HOMOLOGOUS_RECOMBINATION",
  "KEGG_NON_HOMOLOGOUS_END_JOINING",
  "KEGG_NUCLEOTIDE_EXCISION_REPAIR",
  "KEGG_BASE_EXCISION_REPAIR",
  "KEGG_MISMATCH_REPAIR"
)

# üß™ Step 2: Check availability in GSVA matrix
available_pathways <- intersect(repair_pathways, rownames(gsva_scores))
repair_gsva <- gsva_scores[available_pathways, , drop = FALSE]

# üßÆ Step 3: Calculate composite GSVA score
composite_score <- colMeans(repair_gsva, na.rm = TRUE)
matched_samples <- intersect(names(composite_score), clinical_data$sample_id)
clinical_data$DNA_Repair_Score <- composite_score[clinical_data$sample_id]

# üßæ Summary of composite scores
summary(clinical_data$DNA_Repair_Score)

# üß© Step 4: Stratify into High vs Low based on median
clinical_data$DNA_Repair_Group <- ifelse(
  clinical_data$DNA_Repair_Score > median(clinical_data$DNA_Repair_Score, na.rm = TRUE),
  "High", "Low"
) %>% factor(levels = c("Low", "High"))

# üìà Step 5: Kaplan‚ÄìMeier plot
fit <- survfit(Surv(surv_time, event) ~ DNA_Repair_Group, data = clinical_data)
km_plot <- ggsurvplot(
  fit,
  data = clinical_data,
  pval = TRUE,
  conf.int = TRUE,
  risk.table = TRUE,
  title = "Kaplan‚ÄìMeier Plot: Composite DNA Repair GSVA Score",
  xlab = "Days",
  legend.labs = c("Low GSVA", "High GSVA"),
  palette = c("steelblue", "firebrick"),
  ggtheme = theme_minimal(base_size = 14)
)
print(km_plot)

# üìä Step 6: Multivariate Cox model
cox_model <- coxph(Surv(surv_time, event) ~ DNA_Repair_Score + age + gender + stage, data = clinical_data)
summary(cox_model)
```

## üìä Forest Plot: Multivariate Cox Model (DNA Repair + Clinical Covariates)

```{r forest-plot-dna-repair, message=FALSE, warning=FALSE, fig.width=6, fig.height=5, fig.cap="Forest plot showing hazard ratios (HR) from multivariate Cox regression for DNA Repair GSVA score and clinical covariates (age, gender, stage) in LUAD patients."}

# üìä Forest Plot using survminer
ggforest(
  model = cox_model,
  data = clinical_data,
  main = "Forest Plot: DNA Repair GSVA + Clinical Covariates",
  cpositions = c(0.02, 0.22, 0.4),
  fontsize = 1.0,
  refLabel = "Reference",
  noDigits = 2
)

```

## DNA Repair GSVA Composite Signature

Multivariate Cox regression revealed that the composite GSVA score of DNA repair‚Äìassociated pathways is a significant independent prognostic factor in LUAD (HR = 2.89, 95% CI: 1.70‚Äì4.90, p \< 0.001), even after adjusting for age, gender, and pathological stage. This suggests that elevated activation of DNA damage repair programs is associated with worse overall survival, possibly reflecting resistance to genotoxic therapies or enhanced tumor adaptability. In contrast, none of the clinical covariates (including stage) reached statistical significance in this cohort, highlighting the potential clinical utility of GSVA-derived molecular signatures over conventional staging alone.

```{r}
oncogenic_pathways <- c(
  "KEGG_CELL_CYCLE",
  "KEGG_P53_SIGNALING_PATHWAY",
  "KEGG_MAPK_SIGNALING_PATHWAY",
  "KEGG_PI3K_AKT_SIGNALING_PATHWAY",
  "KEGG_DNA_REPLICATION"
)
# üß¨ Check available pathways
available_onco <- intersect(oncogenic_pathways, rownames(gsva_scores))
onco_gsva <- gsva_scores[available_onco, , drop = FALSE]

# üßÆ Calculate composite oncogenic GSVA score
clinical_data$Onco_Score <- colMeans(onco_gsva, na.rm = TRUE)

# üîÅ Stratify high/low
clinical_data$Onco_Group <- ifelse(
  clinical_data$Onco_Score > median(clinical_data$Onco_Score, na.rm = TRUE),
  "High", "Low"
) %>% factor(levels = c("Low", "High"))

# üìà KM plot
fit_onco <- survfit(Surv(surv_time, event) ~ Onco_Group, data = clinical_data)
ggsurvplot(
  fit_onco,
  data = clinical_data,
  pval = TRUE,
  conf.int = TRUE,
  risk.table = TRUE,
  title = "KM Plot: Composite Oncogenic GSVA Score",
  xlab = "Days",
  palette = c("darkgreen", "orangered"),
  ggtheme = theme_minimal()
)

# üìä Cox model
cox_onco <- coxph(Surv(surv_time, event) ~ Onco_Score + age + gender + stage, data = clinical_data)
summary(cox_onco)

```

```{r}
# üì¶ Required libraries
library(pheatmap)
library(dplyr)

# üß¨ Step 1: Normalize DNA Repair Score (Z-score)
clinical_data$DNA_Repair_Z <- scale(clinical_data$DNA_Repair_Score)

# üßæ Step 2: Create heatmap matrix
heat_matrix <- matrix(clinical_data$DNA_Repair_Z, nrow = 1)
rownames(heat_matrix) <- "DNA_Repair_Score"
colnames(heat_matrix) <- clinical_data$sample_id

# üè∑Ô∏è Step 3: Create annotation dataframe
anno <- clinical_data %>%
  select(sample_id, event, stage) %>%
  as.data.frame()
rownames(anno) <- anno$sample_id
anno$sample_id <- NULL

# üé® Step 4: Plot heatmap
pheatmap(
  heat_matrix,
  annotation_col = anno,
  cluster_cols = TRUE,
  cluster_rows = FALSE,
  show_colnames = FALSE,
  main = "DNA Repair GSVA Score vs Survival and Stage",
  fontsize = 12,
  color = colorRampPalette(c("navy", "white", "firebrick3"))(50)
)

```

```{r}
# üß¨ Normalize Oncogenic Score
clinical_data$Onco_Z <- scale(clinical_data$Onco_Score)

# üî≥ Matrix: 1 row (Onco_Score), columns = samples
onco_matrix <- matrix(clinical_data$Onco_Z, nrow = 1)
rownames(onco_matrix) <- "Onco_Score"
colnames(onco_matrix) <- clinical_data$sample_id

# üîç Clinical annotation
anno_onco <- clinical_data %>%
  select(sample_id, event, stage) %>%
  as.data.frame()
rownames(anno_onco) <- anno_onco$sample_id
anno_onco$sample_id <- NULL

# üñºÔ∏è Heatmap
pheatmap(
  onco_matrix,
  annotation_col = anno_onco,
  cluster_cols = TRUE,
  cluster_rows = FALSE,
  show_colnames = FALSE,
  main = "Oncogenic Signature GSVA Score vs Survival and Stage",
  fontsize = 12,
  color = colorRampPalette(c("navy", "white", "firebrick3"))(50)
)

```

```{r}
# üîÅ Stratify by median
clinical_data$Onco_Group <- ifelse(
  clinical_data$Onco_Score > median(clinical_data$Onco_Score, na.rm = TRUE),
  "High", "Low"
) %>% factor(levels = c("Low", "High"))

# üìà KM Survival Plot
fit_onco <- survfit(Surv(surv_time, event) ~ Onco_Group, data = clinical_data)
ggsurvplot(
  fit_onco,
  data = clinical_data,
  pval = TRUE,
  conf.int = TRUE,
  risk.table = TRUE,
  title = "Kaplan‚ÄìMeier Plot: Composite Oncogenic GSVA Score",
  xlab = "Days",
  legend.labs = c("Low GSVA", "High GSVA"),
  palette = c("darkgreen", "orangered"),
  ggtheme = theme_minimal()
)

# üìä Multivariate Cox model
cox_onco <- coxph(Surv(surv_time, event) ~ Onco_Score + age + gender + stage, data = clinical_data)
summary(cox_onco)

```

```{r}
# üìä Combined Cox model with both composite scores
cox_combined <- coxph(Surv(surv_time, event) ~ DNA_Repair_Score + Onco_Score + age + gender + stage, data = clinical_data)
summary(cox_combined)

```

```{r}
# üì¶ If not already loaded
library(survminer)

# üìà Forest plot of combined model
ggforest(
  model = cox_combined,
  data = clinical_data,
  main = "Forest Plot: DNA Repair and Oncogenic GSVA Scores with Clinical Covariates",
  cpositions = c(0.02, 0.25, 0.4),
  fontsize = 1.0,
  refLabel = "Reference",
  noDigits = 2
)

```

## üîç Methylation Data: Load and Inspect

```{r load-methylation-files, message=FALSE, warning=FALSE}

## üìÇ Load probe-level methylation beta matrix (.rds)


# üì¶ Required packages
library(dplyr)

# üìÅ Define file path
file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/processed/TCGA_LUAD_methylation_gene_matrix.rds"


# ‚úÖ Check file exists
if (!file.exists(meth_file)) stop("‚ùå Methylation beta matrix not found.")

# üì• Load methylation matrix
methylation_beta <- readRDS(meth_file)

# üîç Inspect dimensions and contents
cat("‚úÖ Methylation beta matrix loaded.\n")
cat("üî¢ Dimensions (CpG probes √ó samples):\n")
print(dim(methylation_beta))

# üß™ Check column/sample names
cat("üß™ First 5 sample IDs:\n")
print(colnames(methylation_beta)[1:5])

# üß™ Check row names (should be probe IDs like cg00000029)
cat("üß¨ First 5 probe IDs:\n")
print(rownames(methylation_beta)[1:5])


```

```{r Load-gene-level-methylation, message=FALSE, warning=FALSE}
## üìÇ Load Gene-Level Methylation Matrix (TCGA LUAD from UCSC Xena)



# üì¶ Required libraries
library(readr)
library(dplyr)

# üìÅ File path to methylation matrix (gene √ó sample)
meth_file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/raw/TCGA_LUAD_methylation.csv"

# ‚úÖ Check existence
if (!file.exists(meth_file)) stop("‚ùå Methylation file not found.")

# üìñ Load gene-level methylation data
meth_raw <- read_csv(meth_file)

# üîç Inspect shape and contents
cat("‚úÖ Loaded methylation matrix:\n")
print(dim(meth_raw))
print(head(meth_raw[, 1:5]))

# üß¨ First column is gene names
gene_names <- meth_raw[[1]]
meth_matrix <- as.data.frame(meth_raw[, -1])
rownames(meth_matrix) <- gene_names

# üßº Clean sample IDs (if needed)
colnames(meth_matrix) <- make.names(colnames(meth_matrix), unique = TRUE)

# ‚úÖ Final confirmation
cat("‚úÖ Final dimensions (Genes √ó Samples):", nrow(meth_matrix), "√ó", ncol(meth_matrix), "\n")
cat("üß¨ Example gene names:\n")
print(rownames(meth_matrix)[1:5])
cat("üß™ Example sample names:\n")
print(colnames(meth_matrix)[1:5])

```

## üßπ Clean Methylation Beta Matrix (Remove NAs + Duplicates)

```{r clean-methylation-matrix, message=FALSE, warning=FALSE}

# üß¨ Remove probes (rows) where ALL values are NA
meth_matrix_clean <- meth_matrix[rowSums(is.na(meth_matrix)) < ncol(meth_matrix), ]

# üîÅ Remove duplicated probe IDs
meth_matrix_clean <- meth_matrix_clean[!duplicated(rownames(meth_matrix_clean)), ]

# ‚úÖ Summary after cleaning
cat("‚úÖ Cleaned methylation matrix:\n")
cat("Remaining probes:", nrow(meth_matrix_clean), "\n")

```

```{r map-probes-to-genes, message=FALSE, warning=FALSE}
## üß¨ Map probes to genes using Illumina 450k annotation and average to gene level


# üì¶ Load required packages
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(minfi)

# üì• Load probe annotation
anno_obj <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)

# üß¨ Build annotation mapping (probe ‚Üí gene)
probe_anno <- data.frame(
  probe_id = rownames(anno_obj),
  gene_symbol = anno_obj$UCSC_RefGene_Name,
  stringsAsFactors = FALSE
)

# üßπ Clean: remove empty gene annotations
probe_anno <- probe_anno[probe_anno$gene_symbol != "", ]

# üéØ Keep only probes present in your methylation matrix
probe_anno <- probe_anno[probe_anno$probe_id %in% rownames(meth_matrix_clean), ]

# üîÑ Separate multiple gene mappings (e.g., "CDKN2A;CDKN2B")
library(tidyr)
probe_anno <- separate_rows(probe_anno, gene_symbol, sep = ";")

# üîÅ Merge methylation matrix with annotation
meth_annotated <- meth_matrix_clean[probe_anno$probe_id, ]
meth_annotated$gene_symbol <- probe_anno$gene_symbol

# üî¢ Aggregate: average Œ≤-values per gene across multiple probes
gene_meth_matrix <- meth_annotated %>%
  group_by(gene_symbol) %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
  ungroup()

# üß± Convert to matrix format
gene_meth_matrix <- as.data.frame(gene_meth_matrix)
rownames(gene_meth_matrix) <- gene_meth_matrix$gene_symbol
gene_meth_matrix <- gene_meth_matrix[, -1]  # remove redundant column

# ‚úÖ Final summary
cat("‚úÖ Final gene-level methylation matrix:", nrow(gene_meth_matrix), "genes √ó", ncol(gene_meth_matrix), "samples\n")
print(rownames(gene_meth_matrix)[1:5])

```

```{r}
## üìÇ Load Probe-Level Methylation Matrix (Illumina 450k, TCGA LUAD from UCSC Xena)
## üß¨ Map probes to genes using 450k annotation and average to gene-level

library(minfi)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(tidyr)
library(dplyr)

# üì• Load 450k probe annotation
anno_obj <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)

# üß¨ Build mapping: probe_id ‚Üí gene_symbol
probe_anno <- data.frame(
  probe_id = rownames(anno_obj),
  gene_symbol = anno_obj$UCSC_RefGene_Name,
  stringsAsFactors = FALSE
) %>%
  filter(gene_symbol != "") %>%
  separate_rows(gene_symbol, sep = ";") %>%
  filter(probe_id %in% rownames(meth_matrix))

# üîó Subset methylation matrix
meth_subset <- meth_matrix[probe_anno$probe_id, ]
meth_subset$gene_symbol <- probe_anno$gene_symbol

# üî¢ Average Œ≤-values per gene
gene_meth_matrix <- meth_subset %>%
  group_by(gene_symbol) %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")

# üß± Matrix format
gene_meth_matrix <- as.data.frame(gene_meth_matrix)
rownames(gene_meth_matrix) <- gene_meth_matrix$gene_symbol
gene_meth_matrix <- gene_meth_matrix[, -1]

# ‚úÖ Final check
cat("‚úÖ Final gene-level methylation matrix:", nrow(gene_meth_matrix), "genes √ó", ncol(gene_meth_matrix), "samples\n")


```

```{r}
# üîò Save as RDS (preserves rownames and types)
saveRDS(gene_meth_matrix, file = "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/processed/gene_methylation_matrix.rds")
# üßæ Save as CSV
write.csv(gene_meth_matrix, file = "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/processed/gene_methylation_matrix.csv", row.names = TRUE)

```

```{r}
list.files("C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/raw", full.names = TRUE)

```

```{r}
# üì¶ Required libraries
library(readr)
library(dplyr)

# üìÅ Update file path to the correct file
expr_file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/raw/TCGA_LUAD_expr_HGNC.csv"

# ‚úÖ Check file existence
if (!file.exists(expr_file)) stop("‚ùå Expression file not found.")

# üìñ Load the expression matrix
expr_raw <- read_csv(expr_file)

# üîç Inspect first few rows and columns
cat("‚úÖ Expression matrix preview:\n")
print(dim(expr_raw))
print(head(expr_raw[, 1:5]))

# üß¨ Extract gene names from the first column
gene_names <- expr_raw[[1]]
expr_matrix_symbol <- as.data.frame(expr_raw[, -1])
rownames(expr_matrix_symbol) <- gene_names

# üîÑ Log2-transform the expression values (assume TPM or FPKM)
expr_matrix_symbol <- log2(expr_matrix_symbol + 1)

# üßº Clean column names
colnames(expr_matrix_symbol) <- make.names(colnames(expr_matrix_symbol), unique = TRUE)

# ‚úÖ Final check
cat("‚úÖ Final expression matrix:", nrow(expr_matrix_symbol), "genes √ó", ncol(expr_matrix_symbol), "samples\n")

```

```{r}
# Check for non-finite values
sum(!is.finite(as.matrix(expr_matrix_symbol)))  # Should be 0

# Find rows with any NaNs (due to negatives, strings, etc.)
bad_genes <- rownames(expr_matrix_symbol)[rowSums(!is.finite(as.matrix(expr_matrix_symbol))) > 0]
length(bad_genes)
print(head(bad_genes))

```

```{r}
# Remove genes with any non-finite (NaN, Inf) values
expr_matrix_symbol <- expr_matrix_symbol[complete.cases(expr_matrix_symbol), ]
cat("‚úÖ Cleaned expression matrix:", nrow(expr_matrix_symbol), "genes √ó", ncol(expr_matrix_symbol), "samples\n")

```

```{r}
# Ensure methylation matrix exists
stopifnot(exists("gene_meth_matrix"))

# Get common gene symbols
common_genes <- intersect(rownames(expr_matrix_symbol), rownames(gene_meth_matrix))

# Subset both matrices
expr_mat <- expr_matrix_symbol[common_genes, ]
meth_mat <- gene_meth_matrix[common_genes, ]

# Report match summary
cat("üß¨ Matched genes for methylation‚Äìexpression correlation:", length(common_genes), "\n")

```

```{r}
# Load expression matrix again
expr_file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/raw/TCGA_LUAD_expr_HGNC.csv"
expr_raw <- read_csv(expr_file)

# Extract gene symbols and expression values
gene_names <- expr_raw[[1]]
expr_matrix_symbol <- as.data.frame(expr_raw[, -1])
rownames(expr_matrix_symbol) <- gene_names

# Log2 transform
expr_matrix_symbol <- log2(expr_matrix_symbol + 1)

# Extract and clean sample IDs (first 12 chars of TCGA IDs)
expr_ids <- substr(str_replace_all(colnames(expr_matrix_symbol), "\\.", "-"), 1, 12)
colnames(expr_matrix_symbol) <- expr_ids

# Confirm
cat("‚úÖ Expression matrix:", nrow(expr_matrix_symbol), "genes √ó", ncol(expr_matrix_symbol), "samples\n")
head(colnames(expr_matrix_symbol), 5)


```

```{r}
# Load gene-level methylation matrix
gene_meth_matrix <- readRDS("C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/data/processed/gene_methylation_matrix.rds")

# Clean column names
meth_ids <- substr(str_replace_all(colnames(gene_meth_matrix), "\\.", "-"), 1, 12)
colnames(gene_meth_matrix) <- meth_ids

# Confirm
cat("‚úÖ Methylation matrix:", nrow(gene_meth_matrix), "genes √ó", ncol(gene_meth_matrix), "samples\n")
head(colnames(gene_meth_matrix), 5)

```

```{r}
# Count duplicates
dup_samples <- colnames(expr_matrix_symbol)[duplicated(colnames(expr_matrix_symbol))]
cat("‚ùó Duplicate sample IDs in expression matrix:", length(dup_samples), "\n")
print(dup_samples)

```

```{r}
# Remove duplicate columns (keep first occurrence)
expr_matrix_symbol <- expr_matrix_symbol[, !duplicated(colnames(expr_matrix_symbol))]

# Confirm again
cat("‚úÖ Expression matrix (after removing duplicates):", nrow(expr_matrix_symbol), "genes √ó", ncol(expr_matrix_symbol), "samples\n")
head(colnames(expr_matrix_symbol), 5)

```

```{r}
# Intersect samples
common_samples <- intersect(colnames(expr_matrix_symbol), colnames(gene_meth_matrix))
cat("‚úÖ Matched TCGA sample IDs:", length(common_samples), "\n")

# Subset both matrices
expr_matrix_symbol <- expr_matrix_symbol[, common_samples]
gene_meth_matrix   <- gene_meth_matrix[, common_samples]

```

```{r}
all(colnames(expr_matrix_symbol) == colnames(gene_meth_matrix))[1]
```

```{r}
# Ensure identical order of columns
expr_matrix_symbol <- expr_matrix_symbol[, colnames(gene_meth_matrix)]
gene_meth_matrix <- gene_meth_matrix[, colnames(expr_matrix_symbol)]
# Find negative values
summary(expr_matrix_symbol)
sum(expr_matrix_symbol < 0)
sum(is.na(expr_matrix_symbol))
```

```{r}
# Only transform non-negative values, or set negatives to NA first
expr_matrix_symbol[expr_matrix_symbol < 0] <- NA
expr_matrix_log <- log2(expr_matrix_symbol + 1)
```

```{r}
threshold <- ncol(expr_matrix_log) * 0.5
expr_matrix_clean <- expr_matrix_log[rowSums(is.na(expr_matrix_log)) < threshold, ]
threshold <- ncol(expr_matrix_log) * 0.2
expr_matrix_clean <- expr_matrix_log[rowSums(is.na(expr_matrix_log)) <= threshold, ]
```

```{r}
expr_matrix_z <- t(scale(t(expr_matrix_clean)))
# Only keep genes present in both matrices
common_genes <- intersect(rownames(expr_matrix_clean), rownames(gene_meth_matrix))
expr_matrix_final <- expr_matrix_clean[common_genes, ]
meth_matrix_final <- gene_meth_matrix[common_genes, ]

# Calculate correlation for each gene
gene_cors <- mapply(function(expr_row, meth_row) cor(expr_row, meth_row, use="pairwise.complete.obs"),
                    as.data.frame(t(expr_matrix_final)),
                    as.data.frame(t(meth_matrix_final)))
```

```{r}
gene_cors <- mapply(function(expr_row, meth_row) cor(expr_row, meth_row, use="pairwise.complete.obs"),
                    as.data.frame(t(expr_matrix_final)),
                    as.data.frame(t(meth_matrix_final)))
head(gene_cors)               # Show the first few correlation values
summary(gene_cors)            # Get a summary (min, max, mean, etc.)
length(gene_cors)             # How many genes were processed
```

```{r}
# Add gene names to the result
names(gene_cors) <- common_genes

# Strongest positive/negative correlations (excluding NAs)
gene_cors_no_na <- gene_cors[!is.na(gene_cors)]
head(sort(gene_cors_no_na, decreasing = TRUE), 10)  # Top 10 positive
head(sort(gene_cors_no_na, decreasing = FALSE), 10) # Top 10 negative
```

```{r}
hist(gene_cors_no_na, breaks = 30, main = "Gene Expression vs Methylation Correlations", xlab = "Correlation")
```

```{r}
na_genes <- names(gene_cors)[is.na(gene_cors)]
length(na_genes)   # Number of NA genes
head(na_genes)
```

```{r}
spearman_results <- mapply(function(expr_row, meth_row) {
    finite_idx <- which(is.finite(expr_row) & is.finite(meth_row))
    if(length(finite_idx) < 2) {
        return(c(NA, NA))
    } else {
        res <- cor.test(expr_row[finite_idx], meth_row[finite_idx], method = "spearman", exact = FALSE)
        return(c(res$estimate, res$p.value))
    }
}, as.data.frame(t(expr_matrix_final)), as.data.frame(t(meth_matrix_final)))

# Convert to data.frame and name columns
spearman_results_df <- as.data.frame(t(spearman_results))
colnames(spearman_results_df) <- c("spearman_rho", "p_value")
rownames(spearman_results_df) <- rownames(expr_matrix_final)
head(spearman_results_df)
```

```{r}
sig_genes <- spearman_results_df[spearman_results_df$p_value < 0.05, ]
head(sig_genes)
```

```{r}
# Most positive
head(sig_genes[order(-sig_genes$spearman_rho), ], 10)

# Most negative
head(sig_genes[order(sig_genes$spearman_rho), ], 10)
```

```{r}
hist(spearman_results_df$spearman_rho, breaks=30, main="Spearman Correlation (rho)", xlab="rho")
```

```{r}
plot(spearman_results_df$spearman_rho, -log10(spearman_results_df$p_value),
     xlab="Spearman's rho", ylab="-log10(p-value)", pch=20, main="Volcano Plot")
abline(h=-log10(0.05), col="red", lty=2)
```

```{r}
write.csv(spearman_results_df, "spearman_gene_correlations.csv")
write.csv(sig_genes, "significant_spearman_genes.csv")
```

```{r}
# Adjust for multiple testing (FDR)
spearman_results_df$FDR <- p.adjust(spearman_results_df$p_value, method = "BH")
# Filter
high_confidence_hits <- spearman_results_df[spearman_results_df$spearman_rho < -0.4 & spearman_results_df$FDR < 0.01, ]
print(high_confidence_hits)
```

```{r}
getwd()
list.files()
```

```{r load-expression-symbol-mapped, message=FALSE, warning=FALSE}
# üì¶ Load required library
library(readr)

# üìÑ File path
expr_file <- "expr_tpm_cleaned_hgnc.csv"

# ‚úÖ Check file exists
stopifnot(file.exists(expr_file))

# üì• Load expression matrix
expr_symbol_mapped <- read_csv(expr_file)

# üß¨ Set gene symbols as rownames
gene_names <- expr_symbol_mapped[[1]]
expr_symbol_mapped <- as.data.frame(expr_symbol_mapped[ , -1])
rownames(expr_symbol_mapped) <- gene_names

# ‚úÖ Confirm shape
cat("‚úÖ Expression matrix (HGNC symbols):", dim(expr_symbol_mapped)[1], "genes √ó", dim(expr_symbol_mapped)[2], "samples\n")
```

```{r}

cat("Expression matrix dimensions:\n")
print(dim(expr_symbol_mapped))
cat("Example gene names (expression):\n")
print(rownames(expr_symbol_mapped)[1:5])

cat("\nMethylation matrix dimensions:\n")
print(dim(gene_meth_matrix))
cat("Example gene names (methylation):\n")
print(rownames(gene_meth_matrix)[1:5])

```

```{r}
## üîÅ Load + Clean + Deduplicate Expression Matrix (Ensembl ‚Üí HGNC)

# üì¶ Required packages
library(dplyr)
library(readr)
library(biomaRt)

# üì• Load expression matrix (with Ensembl IDs in rownames or column 1)
expr_file <- "C:/Users/karth/OneDrive/Documents/LUAD_Biomarker_Project/expr_tpm_cleaned_hgnc.csv"
expr_raw <- read_csv(expr_file)

# üîç Inspect shape
cat("üìä Raw expression dimensions:", dim(expr_raw), "\n")

# üß¨ First column is Ensembl IDs
ensembl_ids <- expr_raw[[1]]
expr_mat <- as.data.frame(expr_raw[, -1])
rownames(expr_mat) <- ensembl_ids

# üßπ Remove rows with all NA or 0
expr_mat <- expr_mat[rowSums(is.na(expr_mat)) < ncol(expr_mat), ]
expr_mat <- expr_mat[rowSums(expr_mat, na.rm = TRUE) > 0, ]

# üßπ Remove duplicate Ensembl IDs
expr_mat <- expr_mat[!duplicated(rownames(expr_mat)), ]
cat("‚úÖ Cleaned expression matrix:", nrow(expr_mat), "genes √ó", ncol(expr_mat), "samples\n")

# üîÑ Map Ensembl ‚Üí HGNC symbols
cat("üîÑ Mapping Ensembl IDs to HGNC...\n")
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = rownames(expr_mat),
  mart = mart
)

# üßπ Remove empty mappings
mapping <- mapping[mapping$hgnc_symbol != "", ]

# üîÅ Deduplicate mapping
mapping <- mapping[!duplicated(mapping$ensembl_gene_id), ]

# üß¨ Merge with expression
expr_mat$ensembl_gene_id <- rownames(expr_mat)
expr_mapped <- inner_join(mapping, expr_mat, by = c("ensembl_gene_id"))

# üßπ Finalize: Use HGNC as rownames
rownames(expr_mapped) <- expr_mapped$hgnc_symbol
expr_symbol_mapped <- expr_mapped[, !(colnames(expr_mapped) %in% c("ensembl_gene_id", "hgnc_symbol"))]

# ‚úÖ Final dimensions
cat("‚úÖ Expression matrix (HGNC symbols):", nrow(expr_symbol_mapped), "genes √ó", ncol(expr_symbol_mapped), "samples\n")
cat("üß¨ Example HGNC symbols:\n")
print(rownames(expr_symbol_mapped)[1:5])

# üíæ Save cleaned mapped matrix (optional)
saveRDS(expr_symbol_mapped, "expr_symbol_mapped.rds")
write.csv(expr_symbol_mapped, "expr_symbol_mapped.csv")

```

```{r}
# üíæ Save gene-level methylation matrix for reuse
saveRDS(gene_meth_matrix, file = "gene_meth_matrix.rds")
cat("üìÅ Saved gene-level methylation matrix as 'gene_meth_matrix.rds'\n")

```

```{r}
expr_mat <- readRDS("expr_symbol_mapped.rds")
meth_mat <- readRDS("gene_meth_matrix.rds")
## üìÇ Load cleaned expression and methylation matrices
expr_file <- "expr_symbol_mapped.rds"
meth_file <- "gene_meth_matrix.rds"

stopifnot(file.exists(expr_file), file.exists(meth_file))

expr_mat <- readRDS(expr_file)
meth_mat <- readRDS(meth_file)

# ‚úÖ Confirm dimensions
cat("üß¨ Expression matrix:", dim(expr_mat)[1], "genes √ó", dim(expr_mat)[2], "samples\n")
cat("üß¨ Methylation matrix:", dim(meth_mat)[1], "genes √ó", dim(meth_mat)[2], "samples\n")

# üîÅ Convert gene names to uppercase for consistent matching
rownames(expr_mat) <- toupper(rownames(expr_mat))
rownames(meth_mat) <- toupper(rownames(meth_mat))

# üéØ Find common genes
common_genes <- intersect(rownames(expr_mat), rownames(meth_mat))
cat("‚úÖ Matched genes:", length(common_genes), "\n")

# üß¨ Subset both matrices to matched genes
expr_mat_matched <- expr_mat[common_genes, , drop = FALSE]
meth_mat_matched <- meth_mat[common_genes, , drop = FALSE]

# üíæ Save for correlation analysis
saveRDS(expr_mat_matched, "expr_mat_matched.rds")
saveRDS(meth_mat_matched, "meth_mat_matched.rds")

cat("üìÅ Matched matrices saved:\n- expr_mat_matched.rds\n- meth_mat_matched.rds\n")

```

```{r methylation-expression-correlation, message=FALSE, warning=FALSE}



library(tidyverse)
library(ggplot2)

# üì• Load matched gene-level matrices
expr_mat <- readRDS("expr_mat_matched.rds")
meth_mat <- readRDS("meth_mat_matched.rds")

# üß¨ Get common genes and samples
common_genes <- intersect(rownames(expr_mat), rownames(meth_mat))
common_samples <- intersect(colnames(expr_mat), colnames(meth_mat))

cat("‚úÖ Genes for correlation:", length(common_genes), "\n")
cat("‚úÖ Samples for correlation:", length(common_samples), "\n")

# üîÑ Subset matrices to common samples
expr_mat <- expr_mat[common_genes, common_samples]
meth_mat <- meth_mat[common_genes, common_samples]

# üìä Initialize results table
cor_results <- data.frame(gene = character(),
                          spearman_rho = numeric(),
                          p_value = numeric(),
                          stringsAsFactors = FALSE)

# üîÅ Calculate Spearman correlation gene-wise
for (gene in common_genes) {
  expr_values <- as.numeric(expr_mat[gene, ])
  meth_values <- as.numeric(meth_mat[gene, ])
  
  valid <- complete.cases(expr_values, meth_values)
  
  if (sum(valid) > 3) {
    cor_test <- suppressWarnings(cor.test(expr_values[valid], meth_values[valid], method = "spearman"))
    cor_results <- rbind(cor_results, data.frame(
      gene = gene,
      spearman_rho = cor_test$estimate,
      p_value = cor_test$p.value
    ))
  }
}

# üìâ Adjust p-values
cor_results$FDR <- p.adjust(cor_results$p_value, method = "fdr")

# üíæ Save correlation results
write.csv(cor_results, "spearman_gene_correlations.csv", row.names = FALSE)

# üåã Volcano plot
ggplot(cor_results, aes(x = spearman_rho, y = -log10(FDR))) +
  geom_point(aes(color = FDR < 0.05 & spearman_rho < -0.3), size = 2) +
  scale_color_manual(values = c("grey", "red")) +
  geom_vline(xintercept = -0.3, linetype = "dashed", color = "blue") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "blue") +
  theme_minimal() +
  labs(title = "Methylation‚ÄìExpression Spearman Correlation",
       x = "Spearman Rho", y = "-log10(FDR)",
       color = "Significant\nAnti-correlation")

ggsave("methylation_expression_correlation_volcano.png", width = 7, height = 5)

# ‚úÖ Top results
head(cor_results[order(cor_results$FDR), ], 10)

```

```{r}
# Load expression and methylation matrices (HGNC-symbol rows)
expr <- readRDS("expr_mat_matched.rds")       # 598 √ó N
meth <- readRDS("meth_mat_matched.rds")       # 598 √ó N

# Intersect samples
common_samples <- intersect(colnames(expr), colnames(meth))
expr <- expr[, common_samples]
meth <- meth[, common_samples]

# Calculate correlation per gene
cor_list <- lapply(rownames(expr), function(gene) {
  expr_values <- unlist(expr[gene, ])
  meth_values <- unlist(meth[gene, ])
  
  complete <- complete.cases(expr_values, meth_values)
  
  if (sum(complete) >= 10) {
    res <- cor.test(expr_values[complete], meth_values[complete], method = "spearman")
    data.frame(gene = gene, spearman_rho = res$estimate, p_value = res$p.value)
  } else {
    data.frame(gene = gene, spearman_rho = NA, p_value = NA)
  }
})

# Combine and adjust p-values
cor_df <- do.call(rbind, cor_list)
cor_df$FDR <- p.adjust(cor_df$p_value, method = "BH")

# Save to CSV
write.csv(cor_df, "methylation_expression_correlation.csv", row.names = FALSE)

# Preview
head(cor_df[order(cor_df$spearman_rho), ])

```
